{"/home/travis/build/npmtest/node-npmtest-angular-cli/test.js":"/* istanbul instrument in package npmtest_angular_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-angular-cli/lib.npmtest_angular_cli.js":"/* istanbul instrument in package npmtest_angular_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_angular_cli = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_angular_cli = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-angular-cli/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-angular-cli && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_angular_cli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_angular_cli\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_angular_cli.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_angular_cli.rollup.js'] =\n            local.assetsDict['/assets.npmtest_angular_cli.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_angular_cli.__dirname +\n                    '/lib.npmtest_angular_cli.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/lib/cli/index.js":"/*eslint-disable no-console */\n\n// Prevent the dependency validation from tripping because we don't import zone.js. We need\n// it as a peer dependency of @angular/core.\n// require('zone.js')\n\n\n// This file hooks up on require calls to transpile TypeScript.\nconst cli = require('../../ember-cli/lib/cli');\nconst UI = require('../../ember-cli/lib/ui');\nconst Watcher = require('../../ember-cli/lib/models/watcher');\nconst path = require('path');\n\nError.stackTraceLimit = Infinity;\n\nmodule.exports = function(options) {\n\n  // patch UI to not print Ember-CLI warnings (which don't apply to Angular-CLI)\n  UI.prototype.writeWarnLine = function () { }\n\n  // patch Watcher to always default to node, not checking for Watchman\n  Watcher.detectWatcher = function(ui, _options){\n    var options = _options || {};\n    options.watcher = 'node';\n    return Promise.resolve(options);\n  }\n\n  options.cli = {\n    name: 'ng',\n    root: path.join(__dirname, '..', '..'),\n    npmPackage: 'angular-cli'\n  };\n\n  // ensure the environemnt variable for dynamic paths\n  process.env.PWD = path.normalize(process.env.PWD || process.cwd());\n  process.env.CLI_ROOT = process.env.CLI_ROOT || path.resolve(__dirname, '..', '..');\n\n  return cli(options);\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/cli/index.js":"'use strict';\nvar path          = require('path');\n\n// Main entry point\nvar Project       = require('../models/project');\nvar commands      = require('../commands');\nvar tasks         = require('../tasks');\nvar CLI           = require('./cli');\nvar debug         = require('debug')('ember-cli:cli/index');\n\n\n// Options: Array cliArgs, Stream inputStream, Stream outputStream\nmodule.exports = function(options) {\n  var UI = options.UI || require('../ui');\n\n  // TODO: one UI (lib/models/project.js also has one for now...)\n  var ui = new UI({\n    inputStream:  options.inputStream,\n    outputStream: options.outputStream,\n    errorStream:  options.errorStream || process.stderr,\n    errorLog:     options.errorLog || [],\n    ci:           process.env.CI || /^(dumb|emacs)$/.test(process.env.TERM),\n    writeLevel:   ~process.argv.indexOf('--silent') ? 'ERROR' : undefined\n  });\n\n\n  var defaultUpdateCheckerOptions = {\n    checkForUpdates: false\n  };\n\n  var cli = new CLI({\n    ui:        ui,\n    testing:   options.testing,\n    name: options.cli ? options.cli.name : 'ember',\n    disableDependencyChecker: options.disableDependencyChecker,\n    root: options.cli ? options.cli.root : path.resolve(__dirname, '..', '..'),\n    npmPackage: options.cli ? options.cli.npmPackage : 'ember-cli'\n  });\n\n  var project = Project.projectOrnullProject(ui, cli);\n\n  var environment = {\n    tasks:    tasks,\n    cliArgs:  options.cliArgs,\n    commands: commands,\n    project:  project,\n    settings: defaultUpdateCheckerOptions\n  };\n\n  return cli.run(environment);\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/models/project.js":"'use strict';\n\n/**\n@module ember-cli\n*/\nvar Promise            = require('../ext/promise');\nvar path               = require('path');\nvar findup             = Promise.denodeify(require('findup'));\nvar resolve            = Promise.denodeify(require('resolve'));\nvar fs                 = require('fs');\nvar existsSync         = require('exists-sync');\nvar find               = require('lodash/find');\nvar assign             = require('lodash/assign');\nvar forOwn             = require('lodash/forOwn');\nvar merge              = require('lodash/merge');\nvar debug              = require('debug')('ember-cli:project');\nvar Command            = require('../models/command');\nvar UI                 = require('../ui');\nvar nodeModulesPath    = require('node-modules-path');\nvar getPackageBaseName = require('../utilities/get-package-base-name');\n\n/**\n  The Project model is tied to your package.json. It is instiantiated\n  by giving Project.closest the path to your project.\n\n  @class Project\n  @constructor\n  @param {String} root Root directory for the project\n  @param {Object} pkg  Contents of package.json\n*/\nfunction Project(root, pkg, ui, cli) {\n  debug('init root: %s', root);\n  this.root          = root;\n  this.pkg           = pkg;\n  this.ui            = ui;\n  this.cli           = cli;\n  this.addonPackages = {};\n  this.addons = [];\n  this.liveReloadFilterPatterns = [];\n  this.setupNodeModulesPath();\n  this._watchmanInfo = {\n    enabled: false,\n    version: null,\n    canNestRoots: false\n  };\n}\n\nProject.prototype.hasDependencies = function() {\n  return !!this.nodeModulesPath;\n};\n/**\n  Sets the path to the node_modules directory for this\n  project.\n\n  @private\n  @method setupNodeModulesPath\n */\nProject.prototype.setupNodeModulesPath = function() {\n  this.nodeModulesPath = nodeModulesPath(this.root);\n  debug('nodeModulesPath: %s', this.nodeModulesPath);\n};\n\nvar processCwd = process.cwd();\n// ensure NULL_PROJECT is a singleton\nvar NULL_PROJECT;\n\nProject.nullProject = function (ui, cli) {\n  if (NULL_PROJECT) { return NULL_PROJECT; }\n\n  NULL_PROJECT = new Project(processCwd, {}, ui, cli);\n\n  NULL_PROJECT.isEmberCLIProject = function() {\n    return false;\n  };\n\n  NULL_PROJECT.isEmberCLIAddon = function() {\n    return false;\n  };\n\n  NULL_PROJECT.name = function() {\n    return path.basename(process.cwd());\n  };\n\n  NULL_PROJECT.initializeAddons();\n\n  return NULL_PROJECT;\n};\n\n/**\n  Returns the name from package.json.\n\n  @private\n  @method name\n  @return {String} Package name\n */\nProject.prototype.name = function() {\n  return getPackageBaseName(this.pkg.name);\n};\n\n/**\n  Returns whether or not this is an Ember CLI project.\n  This checks whether ember-cli is listed in devDependencies.\n\n  @private\n  @method isEmberCLIProject\n  @return {Boolean} Whether this is an Ember CLI project\n */\nProject.prototype.isEmberCLIProject = function() {\n  return (this.cli ? this.cli.npmPackage : 'ember-cli') in this.dependencies();\n};\n\n/**\n  Returns whether or not this is an Ember CLI addon.\n\n  @method isEmberCLIAddon\n  @return {Boolean} Whether or not this is an Ember CLI Addon.\n */\nProject.prototype.isEmberCLIAddon = function() {\n  return !!this.pkg.keywords && this.pkg.keywords.indexOf('ember-addon') > -1;\n};\n\n/**\n  Returns the path to the configuration.\n\n  @private\n  @method configPath\n  @return {String} Configuration path\n */\nProject.prototype.configPath = function() {\n  var configPath = 'config';\n\n  if (this.pkg['ember-addon'] && this.pkg['ember-addon']['configPath']) {\n    configPath = this.pkg['ember-addon']['configPath'];\n  }\n\n  return path.join(configPath, 'environment');\n};\n\n/**\n  Loads the configuration for this project and its addons.\n\n  @private\n  @method config\n  @param  {String} env Environment name\n  @return {Object}     Merged confiration object\n */\nProject.prototype.config = function(env) {\n  var configPath = this.configPath();\n\n  if (existsSync(path.join(this.root, configPath + '.js'))) {\n    var appConfig = this.require('./' + configPath)(env);\n    var addonsConfig = this.getAddonsConfig(env, appConfig);\n\n    return merge(addonsConfig, appConfig);\n  } else {\n    return this.getAddonsConfig(env, {});\n  }\n};\n\n/**\n  Returns the addons configuration.\n\n  @private\n  @method getAddonsConfig\n  @param  {String} env       Environment name\n  @param  {Object} appConfig Application configuration\n  @return {Object}           Merged configuration of all addons\n */\nProject.prototype.getAddonsConfig = function(env, appConfig) {\n  this.initializeAddons();\n\n  var initialConfig = merge({}, appConfig);\n\n  return this.addons.reduce(function(config, addon) {\n    if (addon.config) {\n      merge(config, addon.config(env, config));\n    }\n\n    return config;\n  }, initialConfig);\n};\n\n/**\n  Returns whether or not the given file name is present in this project.\n\n  @private\n  @method has\n  @param  {String}  file File name\n  @return {Boolean}      Whether or not the file is present\n */\nProject.prototype.has = function(file) {\n  return existsSync(path.join(this.root, file)) || existsSync(path.join(this.root, file + '.js'));\n};\n\n/**\n  Resolves the absolute path to a file.\n\n  @private\n  @method resolve\n  @param  {String} file File to resolve\n  @return {String}      Absolute path to file\n */\nProject.prototype.resolve = function(file) {\n  return resolve(file, {\n    basedir: this.root\n  });\n};\n\n/**\n  Resolves the absolute path to a file synchronously\n\n  @private\n  @method resolveSync\n  @param  {String} file File to resolve\n  @return {String}      Absolute path to file\n */\nProject.prototype.resolveSync = function(file) {\n  return resolve.sync(file, {\n    basedir: this.root\n  });\n};\n\n/**\n  Calls `require` on a given module.\n\n  @private\n  @method require\n  @param  {String} file File path or module name\n  @return {Object}      Imported module\n */\nProject.prototype.require = function(file) {\n  if (/^\\.\\//.test(file)) { // Starts with ./\n    return require(path.join(this.root, file));\n  } else {\n    return require(path.join(this.nodeModulesPath, file));\n  }\n};\n\n/**\n  Returns the dependencies from a package.json\n\n  @private\n  @method dependencies\n  @param  {Object}  pkg            Package object. If false, the current package is used.\n  @param  {Boolean} excludeDevDeps Whether or not development dependencies should be excluded, defaults to false.\n  @return {Object}                 Dependencies\n */\nProject.prototype.dependencies = function(pkg, excludeDevDeps) {\n  pkg = pkg || this.pkg || {};\n\n  var devDependencies = pkg['devDependencies'];\n  if (excludeDevDeps) {\n    devDependencies = {};\n  }\n\n  return assign({}, devDependencies, pkg['dependencies']);\n};\n\n/**\n  Provides the list of paths to consult for addons that may be provided\n  internally to this project. Used for middleware addons with built-in support.\n\n  @private\n  @method supportedInternalAddonPaths\n*/\nProject.prototype.supportedInternalAddonPaths = function() {\n  if (!this.root) { return []; }\n\n  var internalMiddlewarePath = path.join(__dirname, '../tasks/server/middleware');\n\n  return [\n    path.join(internalMiddlewarePath, 'tests-server'),\n    path.join(internalMiddlewarePath, 'history-support'),\n    path.join(internalMiddlewarePath, 'serve-files'),\n    path.join(internalMiddlewarePath, 'proxy-server')\n  ];\n};\n\n/**\n  Loads and initializes all addons for this project.\n\n  @private\n  @method initializeAddons\n */\nProject.prototype.initializeAddons = function() {\n  if (this._addonsInitialized) {\n    return;\n  }\n  this._addonsInitialized = true;\n\n  debug('initializeAddons for: %s', this.name());\n\n  const cliPkg = require(path.resolve(__dirname, '../../../package.json'));\n  const Addon = require('../models/addon');\n  const Constructor = Addon.lookup({\n    name: 'angular-cli',\n    path: path.join(__dirname, '../../../'),\n    pkg: cliPkg,\n  });\n\n  const addon = new Constructor(this.addonParent, this);\n  this.addons = [addon];\n};\n\n/**\n  Returns what commands are made available by addons by inspecting\n  `includedCommands` for every addon.\n\n  @private\n  @method addonCommands\n  @return {Object} Addon names and command maps as key-value pairs\n */\nProject.prototype.addonCommands = function() {\n  var commands = {};\n  this.addons.forEach(function(addon) {\n    var includedCommands = (addon.includedCommands && addon.includedCommands()) || {};\n    var addonCommands = {};\n\n    for (var key in includedCommands) {\n      if (typeof includedCommands[key] === 'function') {\n        addonCommands[key] = includedCommands[key];\n      } else {\n        addonCommands[key] = Command.extend(includedCommands[key]);\n      }\n    }\n    if (Object.keys(addonCommands).length) {\n      commands[addon.name] = addonCommands;\n    }\n  });\n  return commands;\n};\n\n/**\n  Execute a given callback for every addon command.\n  Example:\n\n  ```\n  project.eachAddonCommand(function(addonName, commands) {\n    console.log('Addon ' + addonName + ' exported the following commands:' + commands.keys().join(', '));\n  });\n  ```\n\n  @private\n  @method eachAddonCommand\n  @param  {Function} callback [description]\n */\nProject.prototype.eachAddonCommand = function(callback) {\n  if (this.initializeAddons && this.addonCommands) {\n    this.initializeAddons();\n    var addonCommands = this.addonCommands();\n\n    forOwn(addonCommands, function(commands, addonName) {\n      return callback(addonName, commands);\n    });\n  }\n};\n\n/**\n  Path to the blueprints for this project.\n\n  @private\n  @method localBlueprintLookupPath\n  @return {String} Path to blueprints\n */\nProject.prototype.localBlueprintLookupPath = function() {\n  return path.join(this.root, 'blueprints');\n};\n\n/**\n  Returns a list of paths (including addon paths) where blueprints will be looked up.\n\n  @private\n  @method blueprintLookupPaths\n  @return {Array} List of paths\n */\nProject.prototype.blueprintLookupPaths = function() {\n  if (this.isEmberCLIProject()) {\n    var lookupPaths = [this.localBlueprintLookupPath()];\n    var addonLookupPaths = this.addonBlueprintLookupPaths();\n\n    return lookupPaths.concat(addonLookupPaths);\n  } else {\n    return this.addonBlueprintLookupPaths();\n  }\n};\n\n/**\n  Returns a list of addon paths where blueprints will be looked up.\n\n  @private\n  @method addonBlueprintLookupPaths\n  @return {Array} List of paths\n */\nProject.prototype.addonBlueprintLookupPaths = function() {\n  var addonPaths = this.addons.map(function(addon) {\n    if (addon.blueprintsPath) {\n      return addon.blueprintsPath();\n    }\n  }, this);\n\n  return addonPaths.filter(Boolean).reverse();\n};\n\n/**\n  Reloads package.json\n\n  @private\n  @method reloadPkg\n  @return {Object} Package content\n */\nProject.prototype.reloadPkg = function() {\n  var pkgPath = path.join(this.root, 'package.json');\n\n  // We use readFileSync instead of require to avoid the require cache.\n  this.pkg = JSON.parse(fs.readFileSync(pkgPath, { encoding: 'utf-8' }));\n\n  return this.pkg;\n};\n\n/**\n  Re-initializes addons.\n\n  @private\n  @method reloadAddons\n */\nProject.prototype.reloadAddons = function() {\n  this.reloadPkg();\n  this._addonsInitialized = false;\n  return this.initializeAddons();\n};\n\n/**\n  Find an addon by its name\n\n  @private\n  @method findAddonByName\n  @param  {String} name Addon name as specified in package.json\n  @return {Addon}       Addon instance\n */\nProject.prototype.findAddonByName = function(name) {\n  this.initializeAddons();\n\n  var exactMatch = find(this.addons, function(addon) {\n    return name === addon.name || (addon.pkg && name === addon.pkg.name);\n  });\n\n  if (exactMatch) {\n    return exactMatch;\n  }\n\n  return find(this.addons, function(addon) {\n    return name.indexOf(addon.name) > -1 || (addon.pkg && name.indexOf(addon.pkg.name) > -1);\n  });\n};\n\n/**\n  Generate test file contents.\n\n  This method is supposed to be overwritten by test framework addons\n  like `ember-cli-qunit` and `ember-cli-mocha`.\n\n  @public\n  @method generateTestFile\n  @param {String} moduleName Name of the test module (e.g. `JSHint`)\n  @param {Object[]} tests Array of tests with `name`, `passed` and `errorMessage` properties\n  @return {String} The test file content\n */\nProject.prototype.generateTestFile = function(/* moduleName, tests */) {\n  var message = 'Please install an Ember.js test framework addon or update your dependencies.';\n\n  if (this.ui) {\n    this.ui.writeDeprecateLine(message)\n  } else {\n    console.warn(message);\n  }\n\n  return '';\n};\n\n/**\n  Returns a new project based on the first package.json that is found\n  in `pathName`.\n\n  @private\n  @static\n  @method closest\n  @param  {String} pathName Path to your project\n  @return {Promise}         Promise which resolves to a {Project}\n */\nProject.closest = function(pathName, _ui, _cli) {\n  var ui = ensureUI(_ui);\n  return closestPackageJSON(pathName)\n    .then(function(result) {\n      debug('closest %s -> %s', pathName, result);\n      if (result.pkg && result.pkg.name === 'ember-cli') {\n        return Project.nullProject(_ui, _cli);\n      }\n\n      return new Project(result.directory, result.pkg, ui, _cli);\n    })\n    .catch(function(reason) {\n      handleFindupError(pathName, reason);\n    });\n};\n\n/**\n  Returns a new project based on the first package.json that is found\n  in `pathName`.\n\n  @private\n  @static\n  @method closestSync\n  @param  {String} pathName Path to your project\n  @param  {UI} _ui The UI instance to provide to the created Project.\n  @return {Project}         Project instance\n */\nProject.closestSync = function(pathName, _ui, _cli) {\n  var ui = ensureUI(_ui);\n  var directory, pkg;\n\n  if (_cli && _cli.testing) {\n    directory = existsSync(path.join(pathName, 'package.json')) && process.cwd();\n    if (!directory) {\n      if (pathName.indexOf(path.sep + 'app') > -1) {\n        directory = findupPath(pathName);\n      } else {\n        pkg = {name: 'ember-cli'};\n      }\n    }\n  } else {\n    directory = findupPath(pathName);\n  }\n  if (!pkg) {\n    pkg = JSON.parse(fs.readFileSync(path.join(directory, 'package.json')));\n  }\n\n  debug('dir' + directory);\n  debug('pkg: %s', pkg);\n  if (pkg && pkg.name === 'ember-cli') {\n    return Project.nullProject(_ui, _cli);\n  }\n\n  debug('closestSync %s -> %s', pathName, directory);\n  return new Project(directory, pkg, ui, _cli);\n};\n\n/**\n  Returns a new project based on the first package.json that is found\n  in `pathName`, or the nullProject.\n\n  The nullProject signifies no-project, but abides by the null object pattern\n\n  @private\n  @static\n  @method projectOrnullProject\n  @param  {UI} _ui The UI instance to provide to the created Project.\n  @return {Project}         Project instance\n */\nProject.projectOrnullProject = function(_ui, _cli) {\n  try {\n    return Project.closestSync(process.cwd(), _ui, _cli);\n  } catch (reason) {\n    if (reason instanceof Project.NotFoundError) {\n      return Project.nullProject(_ui, _cli);\n    } else {\n      throw reason;\n    }\n  }\n};\n\n/**\n  Returns the project root based on the first package.json that is found\n\n  @return {String} The project root directory\n */\nProject.getProjectRoot = function () {\n  try {\n    var directory = findup.sync(process.cwd(), 'package.json');\n    var pkg = require(path.join(directory, 'package.json'));\n\n    if (pkg && pkg.name === 'ember-cli') {\n      debug('getProjectRoot: named \\'ember-cli\\'. Will use cwd: %s', process.cwd());\n      return process.cwd();\n    }\n\n    debug('getProjectRoot %s -> %s', process.cwd(), directory);\n    return directory;\n  } catch (reason) {\n    if (isFindupError(reason)) {\n      debug('getProjectRoot: not found. Will use cwd: %s', process.cwd());\n      return process.cwd();\n    } else {\n      throw reason;\n    }\n  }\n};\n\nfunction NotFoundError(message) {\n  this.name = 'NotFoundError';\n  this.message = message;\n  this.stack = (new Error()).stack;\n}\n\nNotFoundError.prototype = Object.create(Error.prototype);\nNotFoundError.prototype.constructor = NotFoundError;\n\nProject.NotFoundError = NotFoundError;\n\nfunction ensureUI(_ui) {\n  var ui = _ui;\n\n  if (!ui) {\n    // TODO: one UI (lib/cli/index.js also has one for now...)\n    ui = new UI({\n      inputStream:  process.stdin,\n      outputStream: process.stdout,\n      ci:           process.env.CI || /^(dumb|emacs)$/.test(process.env.TERM),\n      writeLevel:   ~process.argv.indexOf('--silent') ? 'ERROR' : undefined\n    });\n  }\n\n  return ui;\n}\n\nfunction closestPackageJSON(pathName) {\n  return findup(pathName, 'package.json')\n    .then(function(directory) {\n      return Promise.hash({\n        directory: directory,\n        pkg: require(path.join(directory, 'package.json'))\n      });\n    });\n}\n\nfunction findupPath(pathName) {\n  try {\n    return findup.sync(pathName, 'package.json');\n  } catch (reason) {\n    handleFindupError(pathName, reason);\n  }\n}\n\nfunction isFindupError(reason) {\n  // Would be nice if findup threw error subclasses\n  return reason && /not found/i.test(reason.message);\n}\n\nfunction handleFindupError(pathName, reason) {\n  if (isFindupError(reason)) {\n    throw new NotFoundError('No project found at or up from: `' + pathName + '`');\n  } else {\n    throw reason;\n  }\n}\n\n// Export\nmodule.exports = Project;\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/ext/promise.js":"'use strict';\n\nvar RSVP    = require('rsvp');\nvar Promise = RSVP.Promise;\n\nmodule.exports = PromiseExt;\n\n// Utility functions on the native CTOR need some massaging\nmodule.exports.hash = function() {\n  return this.resolve(RSVP.hash.apply(null, arguments));\n};\n\nmodule.exports.denodeify = function() {\n  var fn = RSVP.denodeify.apply(null, arguments);\n  var Constructor = this;\n  var newFn = function() {\n    return Constructor.resolve(fn.apply(null, arguments));\n  };\n  newFn.__proto__ = arguments[0];\n  return newFn;\n};\n\nmodule.exports.filter = function() {\n  return this.resolve(RSVP.filter.apply(null, arguments));\n};\n\nmodule.exports.map = function() {\n  return this.resolve(RSVP.map.apply(null, arguments));\n};\n\nfunction PromiseExt(resolver, label) {\n  this._superConstructor(resolver, label);\n}\n\nPromiseExt.prototype = Object.create(Promise.prototype);\nPromiseExt.prototype.constructor = PromiseExt;\nPromiseExt.prototype._superConstructor = Promise;\nPromiseExt.__proto__ = Promise;\n\nPromiseExt.prototype.returns = function(value) {\n  return this.then(function() {\n    return value;\n  });\n};\n\nPromiseExt.prototype.invoke = function(method) {\n  var args = Array.prototype.slice(arguments, 1);\n\n  return this.then(function(value) {\n    return value[method].apply(value, args);\n  }, undefined, 'invoke: ' + method + ' with: ' + args);\n};\n\nfunction constructorMethod(promise, methodName, fn) {\n  var Constructor = promise.constructor;\n\n  return promise.then(function(values) {\n    return Constructor[methodName](values, fn);\n  });\n}\n\nPromiseExt.prototype.map = function(mapFn) {\n  return constructorMethod(this, 'map', mapFn);\n};\n\nPromiseExt.prototype.filter = function(filterFn) {\n  return constructorMethod(this, 'filter', filterFn);\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/node_modules/exists-sync/index.js":"'use strict';\nvar path         = require('path');\nvar root         = process.cwd();\nvar accessSync   = require('fs').accessSync;\nvar lstatSync    = require('fs').lstatSync;\nvar readlinkSync = require('fs').readlinkSync;\n\nfunction existsSync(filepath, parent){\n  var depth, link, linkError, linkRoot, relativeLink, resolvedLink, stats;\n  var resolvedPath = path.resolve(filepath);\n  try {\n    stats = lstatSync(resolvedPath);\n    // if symlink, check if target\n    if (stats && stats.isSymbolicLink()) {\n      link         = readlinkSync(resolvedPath);\n      linkRoot     = path.dirname(resolvedPath);\n      \n      if (link && link.indexOf('..') !== -1) {\n        // resolve relative path\n        depth = pathDepth(link);\n        relativeLink = path.relative(path.resolve(linkRoot, depth), path.basename(link));\n        resolvedLink = path.resolve(linkRoot, relativeLink);\n        \n      } else {\n        // assume root and resolve\n        resolvedLink = path.resolve(root, link);\n      }\n      \n      try {\n        accessSync(path.dirname(resolvedLink));\n        \n      } catch (err) {\n        if (err.code === \"ENOENT\") {\n          // Log message for user so they can investigate\n          console.log(err.message);\n          console.log('Please verify that the symlink for ' + resolvedPath + ' can be resolved from ' + root + '.');\n        }\n      }\n      \n      if (parent && parent === resolvedLink) {\n        linkError = new Error('Circular symlink detected: ' + resolvedPath + ' -> ' + resolvedLink);\n        throw linkError;\n      }\n      return existsSync(resolvedLink, resolvedPath);\n      \n    }\n    return true;\n    \n  } catch (err) {\n    if (err.message.match(/Circular symlink detected/)) {\n      throw err;\n    }\n    \n    return checkError(err);\n  }\n}\n\nfunction checkError(err) {\n  return err && err.code === \"ENOENT\" ? false : true;\n}\n\nfunction pathDepth(filepath) {\n  return new Array(filepath.split(path.sep).length).join('..' + path.sep);\n}\n\nmodule.exports = existsSync;","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/models/command.js":"'use strict';\n\nvar nopt                = require('nopt');\nvar chalk               = require('chalk');\nvar path                = require('path');\nvar camelize            = require('ember-cli-string-utils').camelize;\nvar getCallerFile       = require('get-caller-file');\nvar printableProperties = require('../utilities/printable-properties').command;\nvar printCommand        = require('../utilities/print-command');\nvar Promise             = require('../ext/promise');\nvar union               = require('lodash/union');\nvar uniq                = require('lodash/uniq');\nvar uniqBy              = require('lodash/uniqBy');\nvar map                 = require('lodash/map');\nvar reject              = require('lodash/reject');\nvar filter              = require('lodash/filter');\nvar assign              = require('lodash/assign');\nvar defaults            = require('lodash/defaults');\nvar keys                = require('lodash/keys');\nvar EOL                 = require('os').EOL;\nvar CoreObject          = require('../ext/core-object');\nvar debug               = require('debug')('ember-cli:command');\nvar Watcher             = require('../models/watcher');\nvar SilentError         = require('silent-error');\n\nvar allowedWorkOptions = {\n  insideProject: true,\n  outsideProject: true,\n  everywhere: true\n};\n\npath.name = 'Path';\n\nmodule.exports = Command;\n\nfunction Command() {\n  CoreObject.apply(this, arguments);\n\n  this.isWithinProject = this.project.isEmberCLIProject();\n  this.name = this.name || path.basename(getCallerFile(), '.js');\n\n  debug('initialize: name: %s, name: %s', this.name);\n  this.aliases = this.aliases || [];\n\n  // Works Property\n  if (!allowedWorkOptions[this.works]) {\n    throw new Error('The \"' + this.name + '\" command\\'s works field has to ' +\n                    'be either \"everywhere\", \"insideProject\" or \"outsideProject\".');\n  }\n\n  // Options properties\n  this.availableOptions = this.availableOptions || [];\n  this.anonymousOptions = this.anonymousOptions || [];\n  this.registerOptions();\n}\n/*\n  Registers options with command. This method provides the ability to extend or override command options.\n  Expects an object containing anonymousOptions or availableOptions, which it will then merge with\n  existing availableOptions before building the optionsAliases which are used to define shorthands.\n*/\nCommand.prototype.registerOptions = function(options) {\n  var extendedAvailableOptions = options && options.availableOptions || [];\n  var extendedAnonymousOptions = options && options.anonymousOptions || [];\n\n  this.anonymousOptions = union(this.anonymousOptions.slice(0), extendedAnonymousOptions);\n\n  // merge any availableOptions\n  this.availableOptions = union(this.availableOptions.slice(0), extendedAvailableOptions);\n\n  var optionKeys = uniq(map(this.availableOptions, 'name'));\n\n  optionKeys.map(this.mergeDuplicateOption.bind(this));\n\n  this.optionsAliases = this.optionsAliases || {};\n\n  this.availableOptions.map(this.validateOption.bind(this));\n};\n\nCommand.__proto__ = CoreObject;\n\nCommand.prototype.description = null;\nCommand.prototype.works = 'insideProject';\nCommand.prototype.constructor = Command;\n/*\n  Hook for extending a command before it is run in the cli.run command.\n  Most common use case would be to extend availableOptions.\n  @method beforeRun\n  @return {Promise|null}\n*/\nCommand.prototype.beforeRun = function() {\n\n};\n\n/*\n  @method validateAndRun\n  @return {Promise}\n*/\nCommand.prototype.validateAndRun = function(args) {\n  var commandOptions = this.parseArgs(args);\n  // if the help option was passed, resolve with 'callHelp' to call help command\n  if (commandOptions && (commandOptions.options.help || commandOptions.options.h)) {\n    debug(this.name + ' called with help option');\n    return Promise.resolve('callHelp');\n  }\n\n  if (commandOptions === null) {\n    return Promise.resolve();\n  }\n\n  if (this.works === 'insideProject' && !this.isWithinProject) {\n    return Promise.reject(new SilentError(\n      'You have to be inside an angular-cli project in order to use ' +\n      'the ' + chalk.green(this.name) + ' command.'\n    ));\n  }\n\n  if (this.works === 'outsideProject' && this.isWithinProject) {\n    return Promise.reject(new SilentError(\n      'You cannot use the ' + chalk.green(this.name) + ' command inside an angular-cli project.'\n    ));\n  }\n\n  if (this.works === 'insideProject') {\n    if (!this.project.hasDependencies()) {\n      throw new SilentError('node_modules appears empty, you may need to run `npm install`');\n    }\n  }\n\n  return Watcher.detectWatcher(this.ui, commandOptions.options).then(function(options) {\n    if (options._watchmanInfo) {\n      this.project._watchmanInfo = options._watchmanInfo;\n    }\n\n    return this.run(options, commandOptions.args);\n  }.bind(this));\n};\n\n/*\n  Merges any options with duplicate keys in the availableOptions array.\n  Used primarily by registerOptions.\n  @method mergeDuplicateOption\n  @param {String} key\n  @return {Object}\n*/\nCommand.prototype.mergeDuplicateOption = function(key) {\n  var duplicateOptions, mergedOption, mergedAliases;\n  // get duplicates to merge\n  duplicateOptions = filter(this.availableOptions, { 'name': key });\n\n  if (duplicateOptions.length > 1) {\n    // TODO: warn on duplicates and overwriting\n    mergedAliases = [];\n\n    map(duplicateOptions, 'aliases').map(function(alias) {\n      alias.map(function(a) {\n        mergedAliases.push(a);\n      });\n    });\n\n    // merge duplicate options\n    mergedOption = assign.apply(null,duplicateOptions);\n\n    // replace aliases with unique aliases\n    mergedOption.aliases = uniqBy(mergedAliases, function(alias) {\n      if (typeof alias === 'object') {\n        return alias[Object.keys(alias)[0]];\n      }\n      return alias;\n    });\n\n    // remove duplicates from options\n    this.availableOptions = reject(this.availableOptions, { 'name': key });\n    this.availableOptions.push(mergedOption);\n  }\n  return this.availableOptions;\n};\n\n/*\n  Normalizes option, filling in implicit values\n  @method normalizeOption\n  @param {Object} option\n  @return {Object}\n*/\nCommand.prototype.normalizeOption = function(option) {\n  option.key = camelize(option.name);\n  option.required = option.required || false;\n  return option;\n};\n\n/*\n  Assigns option\n  @method assignOption\n  @param {Object} option\n  @param {Object} parsedOptions\n  @param {Object} commandOptions\n  @return {Boolean}\n*/\nCommand.prototype.assignOption = function(option, parsedOptions, commandOptions) {\n  var isValid = isValidParsedOption(option, parsedOptions[option.name]);\n  if (isValid) {\n    if (parsedOptions[option.name] === undefined) {\n      if (option.default !== undefined) {\n        commandOptions[option.key] = option.default;\n      }\n\n      if (this.settings[option.name] !== undefined) {\n        commandOptions[option.key] = this.settings[option.name];\n      } else if (this.settings[option.key] !== undefined) {\n        commandOptions[option.key] = this.settings[option.key];\n      }\n    } else {\n      commandOptions[option.key] = parsedOptions[option.name];\n      delete parsedOptions[option.name];\n    }\n  } else {\n    this.ui.writeLine('The specified command ' + chalk.green(this.name) +\n                      ' requires the option ' + chalk.green(option.name) + '.');\n  }\n  return isValid;\n};\n\n/*\n  Validates option\n  @method validateOption\n  @param {Object} option\n  @return {Boolean}\n*/\nCommand.prototype.validateOption = function(option) {\n  var parsedAliases;\n\n  if (!option.name || !option.type) {\n    throw new Error('The command \"' + this.name + '\" has an option ' +\n                    'without the required type and name fields.');\n  }\n\n  if (option.name !== option.name.toLowerCase()) {\n    throw new Error('The \"' + option.name + '\" option\\'s name of the \"' +\n                     this.name + '\" command contains a capital letter.');\n  }\n\n  this.normalizeOption(option);\n\n  if (option.aliases) {\n    parsedAliases = option.aliases.map(this.parseAlias.bind(this, option));\n    return parsedAliases.map(this.assignAlias.bind(this, option)).indexOf(false) === -1;\n  }\n  return false;\n};\n\n/*\n  Parses alias for an option and adds it to optionsAliases\n  @method parseAlias\n  @param {Object} option\n  @param {Object|String} alias\n  @return {Object}\n*/\nCommand.prototype.parseAlias = function(option, alias) {\n  var aliasType = typeof alias;\n  var key, value, aliasValue;\n\n  if (isValidAlias(alias, option.type)) {\n    if (aliasType === 'string') {\n      key = alias;\n      value = ['--' + option.name];\n    } else if (aliasType === 'object') {\n      key = Object.keys(alias)[0];\n      value = ['--' + option.name, alias[key]];\n    }\n  } else {\n    if (Array.isArray(alias)) {\n      aliasType = 'array';\n      aliasValue = alias.join(',');\n    } else {\n      aliasValue = alias;\n      try {\n        aliasValue = JSON.parse(alias);\n      } catch (e) {\n        var debug = require('debug')('angular-cli/ember-cli/models/command');\n        debug(e);\n      }\n    }\n    throw new Error('The \"' + aliasValue + '\" [type:' + aliasType +\n      '] alias is not an acceptable value. It must be a string or single key' +\n      ' object with a string value (for example, \"value\" or { \"key\" : \"value\" }).');\n  }\n\n  return {\n    key: key,\n    value: value,\n    original: alias\n  };\n\n};\nCommand.prototype.assignAlias = function(option, alias) {\n  var isValid = this.validateAlias(option, alias);\n\n  if (isValid) {\n    this.optionsAliases[alias.key] = alias.value;\n  }\n  return isValid;\n};\n\n/*\n  Validates alias value\n  @method validateAlias\n  @params {Object} alias\n  @return {Boolean}\n*/\nCommand.prototype.validateAlias = function(option, alias) {\n  var key = alias.key;\n  var value = alias.value;\n\n  if (!this.optionsAliases[key]) {\n    return true;\n  } else {\n    if (value[0] !== this.optionsAliases[key][0]) {\n      throw new SilentError('The \"' + key + '\" alias is already in use by the \"' + this.optionsAliases[key][0] +\n        '\" option and cannot be used by the \"' + value[0] + '\" option. Please use a different alias.');\n    } else {\n      if (value[1] !== this.optionsAliases[key][1]) {\n        this.ui.writeLine(chalk.yellow('The \"' + key + '\" alias cannot be overridden. Please use a different alias.'));\n        // delete offending alias from options\n        var index = this.availableOptions.indexOf(option);\n        var aliasIndex = this.availableOptions[index].aliases.indexOf(alias.original);\n        if (this.availableOptions[index].aliases[aliasIndex]) {\n          delete this.availableOptions[index].aliases[aliasIndex];\n        }\n      }\n    }\n    return false;\n  }\n};\n\n/*\n  Parses command arguments and processes\n  @method parseArgs\n  @param {Object} commandArgs\n  @return {Object|null}\n*/\nCommand.prototype.parseArgs = function(commandArgs) {\n  var knownOpts      = {}; // Parse options\n  var commandOptions = {};\n  var parsedOptions;\n\n  var assembleAndValidateOption = function(option) {\n    return this.assignOption(option, parsedOptions, commandOptions);\n  };\n\n  var validateParsed = function(key) {\n    // ignore 'argv', 'h', and 'help'\n    if (!commandOptions.hasOwnProperty(key) && key !== 'argv' && key !== 'h' && key !== 'help') {\n      this.ui.writeLine(chalk.yellow('The option \\'--' + key + '\\' is not registered with the ' + this.name + ' command. ' +\n                        'Run `ng ' + this.name + ' --help` for a list of supported options.'));\n    }\n    if (typeof parsedOptions[key] !== 'object') {\n      commandOptions[camelize(key)] = parsedOptions[key];\n    }\n  };\n\n  this.availableOptions.forEach(function(option) {\n    if (typeof option.type !== 'string') {\n      knownOpts[option.name] = option.type;\n    } else if (option.type === 'Path') {\n      knownOpts[option.name] = path;\n    } else {\n      knownOpts[option.name] = String;\n    }\n  });\n\n  parsedOptions = nopt(knownOpts, this.optionsAliases, commandArgs, 0);\n\n  if (!this.availableOptions.every(assembleAndValidateOption.bind(this))) {\n    return null;\n  }\n\n  keys(parsedOptions).map(validateParsed.bind(this));\n\n  return {\n    options: defaults(commandOptions, this.settings),\n    args: parsedOptions.argv.remain\n  };\n};\n\n/*\n\n*/\nCommand.prototype.run = function(commandArgs) {\n  throw new Error('command must implement run' + commandArgs.toString());\n};\n\nCommand.prototype._printCommand = printCommand;\n\n/*\n  Prints basic help for the command.\n\n  Basic help looks like this:\n\n      ng generate <blueprint> <options...>\n        Generates new code from blueprints\n        aliases: g\n        --dry-run (Default: false)\n        --verbose (Default: false)\n\n  The default implementation is designed to cover all bases\n  but may be overriden if necessary.\n\n  @method printBasicHelp\n*/\nCommand.prototype.printBasicHelp = function() {\n  // ng command-name\n  var output;\n  if (this.isRoot) {\n    output = 'Usage: ' + this.name;\n  } else {\n    output = 'ng ' + this.name;\n  }\n\n  output += this._printCommand();\n  output += EOL;\n\n  return output;\n};\n\n/*\n  Prints detailed help for the command.\n\n  The default implementation is no-op and should be overridden\n  for each command where further help text is required.\n\n  @method printDetailedHelp\n*/\nCommand.prototype.printDetailedHelp = function() {};\n\nCommand.prototype.getJson = function(options) {\n  var json = {};\n\n  printableProperties.forEachWithProperty(function(key) {\n    json[key] = this[key];\n  }, this);\n\n  if (this.addAdditionalJsonForHelp) {\n    this.addAdditionalJsonForHelp(json, options);\n  }\n\n  return json;\n};\n\n/*\n  Validates options parsed by nopt\n*/\nfunction isValidParsedOption(option, parsedOption) {\n  // option.name didn't parse\n  if (parsedOption === undefined) {\n    // no default\n    if (option.default === undefined) {\n      if (option.required) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/*\n  Validates alias. Must be a string or single key object\n*/\nfunction isValidAlias(alias, expectedType) {\n  var type  = typeof alias;\n  var value, valueType;\n  if (type === 'string') {\n    return true;\n  } else if (type === 'object') {\n\n    // no arrays, no multi-key objects\n    if (!Array.isArray(alias) && Object.keys(alias).length === 1) {\n      value = alias[Object.keys(alias)[0]];\n      valueType = typeof value;\n      if (!Array.isArray(expectedType)) {\n        if (valueType === expectedType.name.toLowerCase()) {\n          return true;\n        }\n      } else {\n        if (expectedType.indexOf(value) > -1) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/utilities/printable-properties.js":"'use strict';\n\nvar commandProperties = [\n  'name',\n  'description',\n  'aliases',\n  'works',\n  'availableOptions',\n  'anonymousOptions'\n];\nvar blueprintProperties = [\n  'name',\n  'description',\n  'availableOptions',\n  'anonymousOptions',\n  'overridden'\n];\n\nfunction forEachWithProperty(properties, forEach, context) {\n  return properties.filter(function(key) {\n    return this[key] !== undefined;\n  }, context).forEach(forEach, context);\n}\n\nmodule.exports = {\n  command: {\n    forEachWithProperty: function(forEach, context) {\n      return forEachWithProperty(commandProperties, forEach, context);\n    }\n  },\n  blueprint: {\n    forEachWithProperty: function(forEach, context) {\n      return forEachWithProperty(blueprintProperties, forEach, context);\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/utilities/print-command.js":"'use strict';\n\nvar chalk = require('chalk');\nvar EOL   = require('os').EOL;\n\nmodule.exports = function(initialMargin, shouldDescriptionBeGrey) {\n  initialMargin = initialMargin || '';\n\n  var output = '';\n\n  var options = this.anonymousOptions;\n\n  // <anonymous-option-1> ...\n  if (options.length) {\n    output += ' ' + chalk.yellow(options.map(function(option) {\n      // blueprints we insert brackets, commands already have them\n      if (option.indexOf('<') === 0) {\n        return option;\n      } else {\n        return '<' + option + '>';\n      }\n    }).join(' '));\n  }\n\n  options = this.availableOptions;\n\n  // <options...>\n  if (options.length) {\n    output += ' ' + chalk.cyan('<options...>');\n  }\n\n  // Description\n  var description = this.description;\n  if (description) {\n    if (shouldDescriptionBeGrey) {\n      description = chalk.grey(description);\n    }\n    output += EOL + initialMargin + '  ' + description;\n  }\n\n  // aliases: a b c\n  if (this.aliases && this.aliases.length) {\n    output += EOL + initialMargin + '  ' + chalk.grey('aliases: ' + this.aliases.filter(function(a) { return a; }).join(', '));\n  }\n\n  // --available-option (Required) (Default: value)\n  // ...\n  options.forEach(function(option) {\n    output += EOL + initialMargin + '  ' + chalk.cyan('--' + option.name);\n\n    if (option.values) {\n      output += chalk.cyan('=' + option.values.join('|'));\n    }\n\n    if (option.type) {\n      var types = Array.isArray(option.type) ?\n        option.type.map(formatType).join(', ') :\n        formatType(option.type);\n\n      output += ' ' + chalk.cyan('(' + types + ')');\n    }\n\n    if (option.required) {\n      output += ' ' + chalk.cyan('(Required)');\n    }\n\n    if (option.default !== undefined) {\n      output += ' ' + chalk.cyan('(Default: ' + option.default + ')');\n    }\n\n    if (option.description) {\n      output += ' ' + option.description;\n    }\n\n    if (option.aliases && option.aliases.length) {\n      output += EOL + initialMargin + '    ' + chalk.grey('aliases: ' + option.aliases.map(function(a) {\n        if (typeof a === 'string') {\n          return (a.length > 4 ? '--' : '-') + a + (option.type === Boolean ? '' : ' <value>');\n        } else {\n          var key = Object.keys(a)[0];\n          return (key.length > 4 ? '--' : '-') + key + ' (--' + option.name + '=' + a[key] + ')';\n        }\n      }).join(', '));\n    }\n  });\n\n  return output;\n};\n\nfunction formatType(type) {\n  return typeof type === 'string' ? type : type.name;\n}\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/ext/core-object.js":"'use strict';\n\nfunction CoreObject(options) {\n  Object.assign(this, options);\n}\n\nmodule.exports = CoreObject;\n\nCoreObject.prototype.constructor = CoreObject;\n\nCoreObject.extend = function(options) {\n  var constructor = this;\n  function Class() {\n    constructor.apply(this, arguments);\n    if (this.init) {\n      this.init(options);\n    }\n  }\n\n  Class.__proto__ = CoreObject;\n\n  Class.prototype = Object.create(constructor.prototype);\n  Object.assign(Class.prototype, options);\n  Class.prototype.constructor = Class;\n  Class.prototype._super = constructor.prototype;\n\n  return Class;\n};\n\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/models/watcher.js":"'use strict';\n\nvar chalk   = require('chalk');\nvar Task    = require('./task');\nvar debug   = require('debug')('ember-cli:watcher');\nvar Promise = require('../ext/promise');\nvar exec    = Promise.denodeify(require('child_process').exec);\nvar isWin = /^win/.test(process.platform);\n\nvar Watcher = Task.extend({\n  verbose: true,\n\n  init: function() {\n    var options = this.buildOptions();\n\n    debug('initialize %o', options);\n  },\n\n  didError: function(error) {\n    debug('didError %o', error);\n    this.ui.writeError(error);\n  },\n\n  then: function() {\n    // return this.watcher.then.apply(this.watcher, arguments);\n  },\n\n  didChange: function(results) {\n    debug('didChange %o', results);\n    var totalTime = results.totalTime / 1e6;\n\n    this.ui.writeLine('');\n    this.ui.writeLine(chalk.green('Build successful - ' + Math.round(totalTime) + 'ms.'));\n  },\n\n  on: function() {\n    // this.watcher.on.apply(this.watcher, arguments);\n  },\n\n  off: function() {\n    // this.watcher.off.apply(this.watcher, arguments);\n  },\n  buildOptions: function() {\n    var watcher = this.options && this.options.watcher;\n\n    if (watcher && ['polling', 'watchman', 'node', 'events'].indexOf(watcher) === -1) {\n      throw new Error('Unknown watcher type --watcher=[polling|watchman|node] but was: ' + watcher);\n    }\n\n    return {\n      verbose:  this.verbose,\n      poll:     watcher === 'polling',\n      watchman: watcher === 'watchman' || watcher === 'events',\n      node:     watcher === 'node'\n    };\n  }\n});\n\nWatcher.detectWatcher = function(ui, _options) {\n  var options = _options || {};\n  var watchmanInfo = 'Visit http://ember-cli.com/user-guide/#watchman for more info.';\n\n  if (options.watcher === 'polling') {\n    debug('skip detecting watchman, poll instead');\n    return Promise.resolve(options);\n  } else if (options.watcher === 'node') {\n    debug('skip detecting watchman, node instead');\n    return Promise.resolve(options);\n  } else if (isWin) {\n    debug('watchman isn\\'t supported on windows, node instead');\n    options.watcher = 'node';\n    return Promise.resolve(options);\n  } else {\n    debug('detecting watchman');\n    return exec('watchman version').then(function(output) {\n      var version;\n      try {\n        version = JSON.parse(output).version;\n      } catch (e) {\n        options.watcher = 'node';\n        ui.writeLine('Looks like you have a different program called watchman, falling back to NodeWatcher.');\n        ui.writeLine(watchmanInfo);\n        return options;\n      }\n      debug('detected watchman: %s', version);\n\n      var semver = require('semver');\n      if (semver.satisfies(version, '>= 3.0.0')) {\n        debug('watchman %s does satisfy: %s', version, '>= 3.0.0');\n        options.watcher = 'watchman';\n        options._watchmanInfo = {\n          enabled: true,\n          version: version,\n          canNestRoots: semver.satisfies(version, '>= 3.7.0')\n        };\n      } else {\n        debug('watchman %s does NOT satisfy: %s', version, '>= 3.0.0');\n        ui.writeLine('Invalid watchman found, version: [' + version + '] did not satisfy [>= 3.0.0], falling back to NodeWatcher.');\n        ui.writeLine(watchmanInfo);\n        options.watcher = 'node';\n      }\n\n      return options;\n    }, function(reason) {\n      debug('detecting watchman failed %o', reason);\n      ui.writeLine('Could not start watchman; falling back to NodeWatcher for file system events.');\n      ui.writeLine(watchmanInfo);\n      options.watcher = 'node';\n      return options;\n    });\n  }\n};\n\nmodule.exports = Watcher;\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/models/task.js":"'use strict';\n\nvar CoreObject = require('../ext/core-object');\n\nfunction Task() {\n  CoreObject.apply(this, arguments);\n}\n\nmodule.exports = Task;\n\nTask.__proto__ = CoreObject;\n\nTask.prototype.run = function(/*options*/) {\n  throw new Error('Task needs to have run() defined.');\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/ui/index.js":"'use strict';\n\nvar ora              = require('ora');\nvar Promise          = require('../ext/promise');\nvar EOL              = require('os').EOL;\nvar chalk            = require('chalk');\nvar writeError       = require('./write-error');\n\nvar DEFAULT_WRITE_LEVEL = 'INFO';\n\n// Note: You should use `ui.outputStream`, `ui.inputStream` and `ui.write()`\n//       instead of `process.stdout` and `console.log`.\n//       Thus the pleasant progress indicator automatically gets\n//       interrupted and doesn't mess up the output! -> Convenience :P\n\nmodule.exports = UI;\n\n/*\n  @constructor\n\n  The UI provides the CLI with a unified mechanism for providing output and\n  requesting input from the user. This becomes useful when wanting to adjust\n  logLevels, or mock input/output for tests.\n\n  new UI({\n    inputStream: process.stdin,\n    outputStream: process.stdout,\n    writeLevel: 'DEBUG' | 'INFO' | 'WARNING' | 'ERROR',\n    ci: true | false\n  });\n\n**/\n\nfunction UI(options) {\n  var spinner = this.spinner = ora({ color: 'green' });\n\n  this.through  = require('through');\n\n  // Output stream\n  this.actualOutputStream = options.outputStream;\n  this.outputStream = this.through(function(data) {\n    spinner.stop();\n    this.emit('data', data);\n  });\n\n  this.outputStream.setMaxListeners(0);\n  this.outputStream.pipe(this.actualOutputStream);\n\n  this.inputStream = options.inputStream;\n  this.errorStream = options.errorStream;\n\n  this.errorLog = options.errorLog || [];\n  this.writeLevel = options.writeLevel || DEFAULT_WRITE_LEVEL;\n  this.ci = !!options.ci;\n}\n\n/**\n  Unified mechanism to write a string to the console.\n  Optionally include a writeLevel, this is used to decide if the specific\n  logging mechanism should or should not be printed.\n\n  @method write\n  @param {String} data\n  @param {Number} writeLevel\n*/\nUI.prototype.write = function(data, writeLevel) {\n  if (writeLevel === 'ERROR') {\n    this.errorStream.write(data);\n  } else if (this.writeLevelVisible(writeLevel)) {\n    this.outputStream.write(data);\n  }\n};\n\n/**\n  Unified mechanism to write a string and new line to the console.\n  Optionally include a writeLevel, this is used to decide if the specific\n  logging mechanism should or should not be printed.\n  @method writeLine\n  @param {String} data\n  @param {Number} writeLevel\n*/\nUI.prototype.writeLine = function(data, writeLevel) {\n  this.write(data + EOL, writeLevel);\n};\n\n/**\n  Helper method to write a string with the DEBUG writeLevel and gray chalk\n  @method writeDebugLine\n  @param {String} data\n*/\nUI.prototype.writeDebugLine = function(data) {\n  this.writeLine(chalk.gray(data), 'DEBUG');\n};\n\n/**\n  Helper method to write a string with the INFO writeLevel and cyan chalk\n  @method writeInfoLine\n  @param {String} data\n*/\nUI.prototype.writeInfoLine = function(data) {\n  this.writeLine(chalk.cyan(data), 'INFO');\n};\n\n/**\n  Helper method to write a string with the WARNING writeLevel and yellow chalk.\n  Optionally include a test. If falsy, the warning will be printed. By default, warnings\n  will be prepended with WARNING text when printed.\n  @method writeWarnLine\n  @param {String} data\n  @param {Boolean} test\n  @param {Boolean} prepend\n*/\nUI.prototype.writeWarnLine = function(data, test, prepend) {\n  if (test) { return; }\n\n  data = this.prependLine('WARNING', data, prepend);\n  this.writeLine(chalk.yellow(data), 'WARNING', test);\n};\n\n/**\n  Helper method to write a string with the WARNING writeLevel and yellow chalk.\n  Optionally include a test. If falsy, the deprecation will be printed. By default deprecations\n  will be prepended with DEPRECATION text when printed.\n  @method writeDeprecateLine\n  @param {String} data\n  @param {Boolean} test\n  @param {Boolean} prepend\n*/\nUI.prototype.writeDeprecateLine = function(data, test, prepend) {\n  data = this.prependLine('DEPRECATION', data, prepend);\n  this.writeWarnLine(data, test, false);\n};\n\n/**\n  Utility method to prepend a line with a flag-like string (i.e., WARNING).\n  @method prependLine\n  @param {String} prependData\n  @param {String} data\n  @param {Boolean} prepend\n*/\nUI.prototype.prependLine = function(prependData, data, prepend) {\n  if (typeof prepend === 'undefined' || prepend) {\n    data = prependData + ': ' + data;\n  }\n\n  return data;\n};\n\n/**\n  Unified mechanism to an Error to the console.\n  This will occure at a writeLevel of ERROR\n\n  @method writeError\n  @param {Error} error\n*/\nUI.prototype.writeError = function(error) {\n  writeError(this, error);\n};\n\n/**\n  Sets the write level for the UI. Valid write levels are 'DEBUG', 'INFO',\n  'WARNING', and 'ERROR'.\n\n  @method setWriteLevel\n  @param {String} level\n*/\nUI.prototype.setWriteLevel = function(level) {\n  if (Object.keys(this.WRITE_LEVELS).indexOf(level) === -1) {\n    throw new Error('Unknown write level. Valid values are \\'DEBUG\\', \\'INFO\\', \\'WARNING\\', and \\'ERROR\\'.');\n  }\n\n  this.writeLevel = level;\n};\n\nUI.prototype.startProgress = function(message/*, stepString*/) {\n  if (this.writeLevelVisible('INFO')) {\n    if (this.ci) {\n      this.writeLine(message);\n    } else {\n      this.spinner.text = message;\n      this.spinner.start();\n    }\n  }\n};\n\nUI.prototype.stopProgress = function() {\n  if (this.writeLevelVisible('INFO') && !this.ci) {\n    this.spinner.stop();\n  }\n};\n\nUI.prototype.prompt = function(questions, callback) {\n  var inquirer = require('inquirer');\n\n  // If no callback was provided, automatically return a promise\n  if (callback) {\n    inquirer.prompt(questions, callback);\n  } else {\n    return new Promise(function(resolve) {\n      inquirer.prompt(questions, resolve);\n    });\n  }\n};\n\n/**\n  @property WRITE_LEVELS\n  @private\n  @type Object\n*/\nUI.prototype.WRITE_LEVELS = {\n  'DEBUG': 1,\n  'INFO': 2,\n  'WARNING': 3,\n  'ERROR': 4\n};\n\n/**\n  Whether or not the specified write level should be printed by this UI.\n\n  @method writeLevelVisible\n  @private\n  @param {String} writeLevel\n  @return {Boolean}\n*/\nUI.prototype.writeLevelVisible = function(writeLevel) {\n  var levels = this.WRITE_LEVELS;\n  writeLevel = writeLevel || DEFAULT_WRITE_LEVEL;\n\n  return levels[writeLevel] >= levels[this.writeLevel];\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/ui/write-error.js":"'use strict';\nvar chalk = require('chalk');\n\nmodule.exports = function writeError(ui, error) {\n  if (!error) { return; }\n\n  // Uglify errors have a filename instead\n  var fileName = error.file || error.filename;\n  if (fileName) {\n    if (error.line) {\n      fileName += error.col ? ' (' + error.line + ':' + error.col + ')' : ' (' + error.line + ')';\n    }\n    ui.writeLine(chalk.red('File: ' + fileName), 'ERROR');\n  }\n\n  if (error.message) {\n    ui.writeLine(chalk.red(error.message), 'ERROR');\n  } else {\n    ui.writeLine(chalk.red(error), 'ERROR');\n  }\n\n  if (error.stack) {\n    ui.writeLine(error.stack, 'ERROR');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/utilities/get-package-base-name.js":"'use strict';\n\nmodule.exports = function (name) {\n  var packageParts;\n\n  if (!name) {\n    return null;\n  }\n\n  packageParts = name.split('/');\n  return packageParts[(packageParts.length - 1)];\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/commands.js":"\nmodule.exports = { 'Unknown': require('./commands/unknown') };\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/commands/unknown.js":"'use strict';\n\nvar Command     = require('../models/command');\nvar SilentError = require('silent-error');\nvar chalk       = require('chalk');\n\nmodule.exports = Command.extend({\n  skipHelp: true,\n  unknown: true,\n\n  printBasicHelp: function() {\n    return chalk.red('No help entry for \\'' + this.name + '\\'');\n  },\n\n  validateAndRun: function() {\n    throw new SilentError('The specified command ' + this.name +\n                          ' is invalid. For available options, see' +\n                          ' `ng help`.');\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/tasks.js":"\nmodule.exports = {\n  CreateAndStepIntoDirectory: require('./tasks/create-and-step-into-directory'),\n  DestroyFromBlueprint: require('./tasks/destroy-from-blueprint'),\n  GenerateFromBlueprint: require('./tasks/generate-from-blueprint'),\n  GitInit: require('./tasks/git-init'),\n  InstallBlueprint: require('./tasks/install-blueprint'),\n  NpmInstall: require('./tasks/npm-install'),\n  NpmTask: require('./tasks/npm-task'),\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/tasks/create-and-step-into-directory.js":"'use strict';\n\n// Creates a directory with the name directoryName in cwd and then sets cwd to\n// this directory.\n\nvar Promise     = require('../ext/promise');\nvar fs          = require('fs');\nvar existsSync  = require('exists-sync');\nvar mkdir       = Promise.denodeify(fs.mkdir);\nvar Task        = require('../models/task');\nvar SilentError = require('silent-error');\n\nmodule.exports = Task.extend({\n  // Options: String directoryName, Boolean: dryRun\n\n  warnDirectoryAlreadyExists: function warnDirectoryAlreadyExists() {\n    var message = 'Directory \\'' + this.directoryName + '\\' already exists.';\n    return new SilentError(message);\n  },\n\n  run: function(options) {\n    var directoryName = this.directoryName = options.directoryName;\n    if (options.dryRun) {\n      return new Promise(function(resolve, reject) {\n        if (existsSync(directoryName)) {\n          return reject(this.warnDirectoryAlreadyExists());\n        }\n        resolve();\n      }.bind(this));\n    }\n\n    return mkdir(directoryName)\n      .catch(function(err) {\n        if (err.code === 'EEXIST') {\n          throw this.warnDirectoryAlreadyExists();\n        } else {\n          throw err;\n        }\n      }.bind(this))\n      .then(function() {\n        var cwd = process.cwd();\n        process.chdir(directoryName);\n        return { initialDirectory: cwd };\n      });\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/tasks/destroy-from-blueprint.js":"/*jshint quotmark: false*/\n\n'use strict';\n\nvar Generate     = require('./generate-from-blueprint');\n\nmodule.exports = Generate.extend({\n  blueprintFunction: 'uninstall'\n});\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/tasks/generate-from-blueprint.js":"/*jshint quotmark: false*/\n\n'use strict';\n\nvar Promise      = require('../ext/promise');\nvar Blueprint    = require('../models/blueprint');\nvar Task         = require('../models/task');\nvar parseOptions = require('../utilities/parse-options');\nvar merge        = require('lodash/merge');\n\nmodule.exports = Task.extend({\n  blueprintFunction: 'install',\n\n  run: function(options) {\n    var self = this;\n    var name = options.args[0];\n    var noAddonBlueprint = ['mixin', 'blueprint-test'];\n\n    var mainBlueprint  = this.lookupBlueprint(name, options.ignoreMissingMain);\n    var testBlueprint  = this.lookupBlueprint(name + '-test', true);\n    // lookup custom addon blueprint\n    var addonBlueprint = this.lookupBlueprint(name + '-addon', true);\n    // otherwise, use default addon-import\n\n    if (noAddonBlueprint.indexOf(name) < 0 && !addonBlueprint && (mainBlueprint && mainBlueprint.supportsAddon()) && options.args[1]) {\n      addonBlueprint = this.lookupBlueprint('addon-import', true);\n    }\n\n    if (options.ignoreMissingMain && !mainBlueprint) {\n      return Promise.resolve();\n    }\n\n    if (options.dummy) {\n      // don't install test or addon reexport for dummy\n      if (this.project.isEmberCLIAddon()) {\n        testBlueprint = null;\n        addonBlueprint = null;\n      }\n    }\n\n    var entity = {\n      name: options.args[1],\n      options: parseOptions(options.args.slice(2))\n    };\n\n    var blueprintOptions = {\n      target: this.project.root,\n      entity: entity,\n      ui: this.ui,\n      project: this.project,\n      settings: this.settings,\n      testing: this.testing,\n      taskOptions: options,\n      originBlueprintName: name\n    };\n\n    blueprintOptions = merge(blueprintOptions, options || {});\n\n    return mainBlueprint[this.blueprintFunction](blueprintOptions)\n      .then(function() {\n        if (!testBlueprint) { return; }\n\n        if (testBlueprint.locals === Blueprint.prototype.locals) {\n          testBlueprint.locals = function(options) {\n            return mainBlueprint.locals(options);\n          };\n        }\n\n        var testBlueprintOptions = merge({} , blueprintOptions, { installingTest: true });\n\n        return testBlueprint[self.blueprintFunction](testBlueprintOptions);\n      })\n      .then(function() {\n        if (!addonBlueprint || name.match(/-addon/)) { return; }\n        if (!this.project.isEmberCLIAddon() && blueprintOptions.inRepoAddon === null) { return; }\n\n        if (addonBlueprint.locals === Blueprint.prototype.locals) {\n          addonBlueprint.locals = function(options) {\n            return mainBlueprint.locals(options);\n          };\n        }\n\n        var addonBlueprintOptions = merge({}, blueprintOptions, { installingAddon: true });\n\n        return addonBlueprint[self.blueprintFunction](addonBlueprintOptions);\n      }.bind(this));\n  },\n\n  lookupBlueprint: function(name, ignoreMissing) {\n    return Blueprint.lookup(name, {\n      paths: this.project.blueprintLookupPaths(),\n      ignoreMissing: ignoreMissing\n    });\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/models/blueprint.js":"'use strict';\n\n/**\n@module ember-cli\n*/\nvar FileInfo            = require('./file-info');\nvar Promise             = require('../ext/promise');\nvar chalk               = require('chalk');\nvar printableProperties = require('../utilities/printable-properties').blueprint;\nvar sequence            = require('../utilities/sequence');\nvar printCommand        = require('../utilities/print-command');\nvar fs                  = require('fs-extra');\nvar existsSync          = require('exists-sync');\nvar inflector           = require('inflection');\nvar minimatch           = require('minimatch');\nvar path                = require('path');\nvar stat                = Promise.denodeify(fs.stat);\nvar stringUtils         = require('ember-cli-string-utils');\nvar compact             = require('lodash/compact');\nvar intersect           = require('lodash/intersection');\nvar uniq                = require('lodash/uniq');\nvar zipObject           = require('lodash/zipObject');\nvar includes            = require('lodash/includes');\nvar any                 = require('lodash/some');\nvar cloneDeep           = require('lodash/cloneDeep');\nvar keys                = require('lodash/keys');\nvar merge               = require('lodash/merge');\nvar values              = require('lodash/values');\nvar walkSync            = require('walk-sync');\nvar writeFile           = Promise.denodeify(fs.outputFile);\nvar removeFile          = Promise.denodeify(fs.remove);\nvar SilentError         = require('silent-error');\nvar CoreObject          = require('../ext/core-object');\nvar EOL                 = require('os').EOL;\nvar debug               = require('debug')('ember-cli:blueprint');\nvar normalizeEntityName = require('ember-cli-normalize-entity-name');\n\nmodule.exports = Blueprint;\n\n/**\n  A blueprint is a bundle of template files with optional install\n  logic.\n\n  Blueprints follow a simple structure. Let's take the built-in\n  `controller` blueprint as an example:\n\n  ```\n  blueprints/controller\n   files\n      app\n         __path__\n             __name__.js\n   index.js\n\n  blueprints/controller-test\n   files\n      tests\n          unit\n              controllers\n                  __test__.js\n   index.js\n  ```\n\n  ## Files\n\n  `files` contains templates for the all the files to be\n  installed into the target directory.\n\n  The `__name__` token is subtituted with the dasherized\n  entity name at install time. For example, when the user\n  invokes `ember generate controller foo` then `__name__` becomes\n  `foo`. When the `--pod` flag is used, for example `ember\n  generate controller foo --pod` then `__name__` becomes\n  `controller`.\n\n  The `__path__` token is substituted with the blueprint\n  name at install time. For example, when the user invokes\n  `ember generate controller foo` then `__path__` becomes\n  `controller`. When the `--pod` flag is used, for example\n  `ember generate controller foo --pod` then `__path__`\n  becomes `foo` (or `<podModulePrefix>/foo` if the\n  podModulePrefix is defined). This token is primarily for\n  pod support, and is only necessary if the blueprint can be\n  used in pod structure. If the blueprint does not require pod\n  support, simply use the blueprint name instead of the\n  `__path__` token.\n\n  The `__test__` token is substituted with the dasherized\n  entity name and appended with `-test` at install time.\n  This token is primarily for pod support and only necessary\n  if the blueprint requires support for a pod structure. If\n  the blueprint does not require pod support, simply use the\n  `__name__` token instead.\n\n  ## Template Variables (AKA Locals)\n\n  Variables can be inserted into templates with\n  `<%= someVariableName %>`.\n\n  For example, the built-in `util` blueprint\n  `files/app/utils/__name__.js` looks like this:\n\n  ```js\n  export default function <%= camelizedModuleName %>() {\n    return true;\n  }\n  ```\n\n  `<%= camelizedModuleName %>` is replaced with the real\n  value at install time.\n\n  The following template variables are provided by default:\n\n  - `dasherizedPackageName`\n  - `classifiedPackageName`\n  - `dasherizedModuleName`\n  - `classifiedModuleName`\n  - `camelizedModuleName`\n\n  `packageName` is the project name as found in the project's\n  `package.json`.\n\n  `moduleName` is the name of the entity being generated.\n\n  The mechanism for providing custom template variables is\n  described below.\n\n  ## Index.js\n\n  Custom installation and uninstallation behaviour can be added\n  by overriding the hooks documented below. `index.js` should\n  export a plain object, which will extend the prototype of the\n  `Blueprint` class. If needed, the original `Blueprint` prototype\n  can be accessed through the `_super` property.\n\n  ```js\n  module.exports = {\n    locals: function(options) {\n      // Return custom template variables here.\n      return {};\n    },\n\n    normalizeEntityName: function(entityName) {\n      // Normalize and validate entity name here.\n      return entityName;\n    },\n\n    fileMapTokens: function(options) (\n      // Return custom tokens to be replaced in your files\n      return {\n        __token__: function(options){\n          // logic to determine value goes here\n          return 'value';\n        }\n      }\n    },\n\n    filesPath: function(options) {\n      return path.join(this.path, 'files');\n    },\n\n    beforeInstall: function(options) {},\n    afterInstall: function(options) {},\n    beforeUninstall: function(options) {},\n    afterUninstall: function(options) {}\n\n  };\n  ```\n\n  ## Blueprint Hooks\n\n  As shown above, the following hooks are available to\n  blueprint authors:\n\n  - `locals`\n  - `normalizeEntityName`\n  - `fileMapTokens`\n  - `filesPath`\n  - `beforeInstall`\n  - `afterInstall`\n  - `beforeUninstall`\n  - `afterUninstall`\n\n  ### locals\n\n  Use `locals` to add custom tempate variables. The method\n  receives one argument: `options`. Options is an object\n  containing general and entity-specific options.\n\n  When the following is called on the command line:\n\n  ```sh\n  ember generate controller foo --type=array --dry-run\n  ```\n\n  The object passed to `locals` looks like this:\n\n  ```js\n  {\n    entity: {\n      name: 'foo',\n      options: {\n        type: 'array'\n      }\n    },\n    dryRun: true\n  }\n  ```\n\n  This hook must return an object or a Promise which resolves to an object.\n  The resolved object will be merged with the aforementioned default locals.\n\n  ### normalizeEntityName\n\n  Use the `normalizeEntityName` hook to add custom normalization and\n  validation of the provided entity name. The default hook does not\n  make any changes to the entity name, but makes sure an entity name\n  is present and that it doesn't have a trailing slash.\n\n  This hook receives the entity name as its first argument. The string\n  returned by this hook will be used as the new entity name.\n\n  ### fileMapTokens\n\n  Use `fileMapTokens` to add custom fileMap tokens for use\n  in the `mapFile` method. The hook must return an object in the\n  following pattern:\n\n  ```js\n  {\n    __token__: function(options){\n      // logic to determine value goes here\n      return 'value';\n    }\n  }\n  ```\n\n  It will be merged with the default `fileMapTokens`, and can be used\n  to override any of the default tokens.\n\n  Tokens are used in the files folder (see `files`), and get replaced with\n  values when the `mapFile` method is called.\n\n  ### filesPath\n\n  Use `filesPath` to define where the blueprint files to install are located.\n  This can be used to customize which set of files to install based on options\n  or environmental variables. It defaults to the `files` directory within the\n  blueprint's folder.\n\n  ### beforeInstall & beforeUninstall\n\n  Called before any of the template files are processed and receives\n  the the `options` and `locals` hashes as parameters. Typically used for\n  validating any additional command line options or for any asynchronous\n  setup that is needed.   As an example, the `controller` blueprint validates\n  its `--type` option in this hook.  If you need to run any asynchronous code,\n  wrap it in a promise and return that promise from these hooks.  This will\n  ensure that your code is executed correctly.\n\n  ### afterInstall & afterUninstall\n\n  The `afterInstall` and `afterUninstall` hooks receives the same\n  arguments as `locals`. Use it to perform any custom work after the\n  files are processed. For example, the built-in `route` blueprint\n  uses these hooks to add and remove relevant route declarations in\n  `app/router.js`.\n\n  ### Overriding Install\n\n  If you don't want your blueprint to install the contents of\n  `files` you can override the `install` method. It receives the\n  same `options` object described above and must return a promise.\n  See the built-in `resource` blueprint for an example of this.\n\n  @class Blueprint\n  @constructor\n  @extends CoreObject\n  @param {String} [blueprintPath]\n*/\nfunction Blueprint(blueprintPath) {\n  this.path = blueprintPath;\n  this.name = path.basename(blueprintPath);\n}\n\nBlueprint.__proto__ = CoreObject;\nBlueprint.prototype.constructor = Blueprint;\n\nBlueprint.prototype.availableOptions = [];\nBlueprint.prototype.anonymousOptions = ['name'];\n\n/**\n  Hook to specify the path to the blueprint's files. By default this is\n  `path.join(this.path, 'files)`.\n\n  @method filesPath\n  @param {Object} options\n  @return {String} Path to the blueprints files directory.\n*/\n\nBlueprint.prototype.filesPath = function() {\n  return path.join(this.path, 'files');\n};\n\n/**\n  Used to retrieve files for blueprint. The `file` param is an\n  optional string that is turned into a glob.\n\n  @method files\n  @return {Array} Contents of the blueprint's files directory\n*/\nBlueprint.prototype.files = function() {\n  if (this._files) { return this._files; }\n\n  var filesPath = this.filesPath(this.options);\n  if (existsSync(filesPath)) {\n    this._files = walkSync(filesPath);\n  } else {\n    this._files = [];\n  }\n\n  return this._files;\n};\n\n/**\n  @method srcPath\n  @param {String} file\n  @return {String} Resolved path to the file\n*/\nBlueprint.prototype.srcPath = function(file) {\n  return path.resolve(this.filesPath(this.options), file);\n};\n\n/**\n  Hook for normalizing entity name\n  @method normalizeEntityName\n  @param {String} entityName\n  @return {null}\n*/\nBlueprint.prototype.normalizeEntityName = function(entityName) {\n  return normalizeEntityName(entityName);\n};\n\n/**\n  Write a status and message to the UI\n  @private\n  @method _writeStatusToUI\n  @param {Function} chalkColor\n  @param {String} keyword\n  @param {String} message\n*/\nBlueprint.prototype._writeStatusToUI = function(chalkColor, keyword, message) {\n  if (this.ui) {\n    this.ui.writeLine('  ' + chalkColor(keyword) + ' ' + message);\n  }\n};\n\n/**\n  @private\n  @method _writeFile\n  @param {Object} info\n  @return {Promise}\n*/\nBlueprint.prototype._writeFile = function(info) {\n  if (!this.dryRun) {\n    return writeFile(info.outputPath, info.render());\n  }\n};\n\n/**\n  Actions lookup\n  @private\n*/\n\nBlueprint.prototype._actions = {\n  write: function(info) {\n    this._writeStatusToUI(chalk.green, 'create', info.displayPath);\n    return this._writeFile(info);\n  },\n  skip: function(info) {\n    var label = 'skip';\n\n    if (info.resolution === 'identical') {\n      label = 'identical';\n    }\n\n    this._writeStatusToUI(chalk.yellow, label, info.displayPath);\n  },\n\n  overwrite: function(info) {\n    this._writeStatusToUI(chalk.yellow, 'overwrite', info.displayPath);\n    return this._writeFile(info);\n  },\n\n  edit: function(info) {\n    this._writeStatusToUI(chalk.green, 'edited', info.displayPath);\n  },\n\n  remove: function(info) {\n    this._writeStatusToUI(chalk.red, 'remove', info.displayPath);\n    if (!this.dryRun) {\n      return removeFile(info.outputPath);\n    }\n  }\n};\n\n/**\n  Calls an action.\n  @private\n  @method _commit\n  @param {Object} result\n  @return {Promise}\n  @throws {Error} Action doesn't exist.\n*/\nBlueprint.prototype._commit = function(result) {\n  var action = this._actions[result.action];\n\n  if (action) {\n    return action.call(this, result);\n  } else {\n    throw new Error('Tried to call action \\\"' + result.action + '\\\" but it does not exist');\n  }\n};\n\n/**\n  Prints warning for pod unsupported.\n  @private\n  @method _checkForPod\n*/\nBlueprint.prototype._checkForPod = function(verbose) {\n  if (!this.hasPathToken && this.pod && verbose) {\n    this.ui.writeLine(chalk.yellow('You specified the pod flag, but this' +\n      ' blueprint does not support pod structure. It will be generated with' +\n      ' the default structure.'));\n  }\n};\n\n/**\n  @private\n  @method _normalizeEntityName\n  @param {Object} entity\n*/\nBlueprint.prototype._normalizeEntityName = function(entity) {\n  if (entity) {\n    entity.name = this.normalizeEntityName(entity.name);\n  }\n};\n\n/**\n  @private\n  @method _checkInRepoAddonExists\n  @param {String} inRepoAddon\n*/\nBlueprint.prototype._checkInRepoAddonExists = function(inRepoAddon) {\n  if (inRepoAddon) {\n    if (!inRepoAddonExists(inRepoAddon, this.project.root)) {\n      throw new SilentError('You specified the in-repo-addon flag, but the' +\n        ' in-repo-addon \\'' + inRepoAddon + '\\' does not exist. Please' +\n        ' check the name and try again.');\n    }\n  }\n};\n\n/**\n  @private\n  @method _process\n  @param {Object} options\n  @param {Function} beforeHook\n  @param {Function} process\n  @param {Function} afterHook\n*/\nBlueprint.prototype._process = function(options, beforeHook, process, afterHook) {\n  var self = this;\n  var intoDir = options.target;\n\n  return this._locals(options).then(function (locals) {\n    return Promise.resolve()\n      .then(beforeHook.bind(self, options, locals))\n      .then(process.bind(self, intoDir, locals)).map(self._commit.bind(self))\n      .then(afterHook.bind(self, options));\n  });\n};\n\n/**\n  @method install\n  @param {Object} options\n  @return {Promise}\n*/\nBlueprint.prototype.install = function(options) {\n  var ui       = this.ui     = options.ui;\n  var dryRun   = this.dryRun = options.dryRun;\n  this.project = options.project;\n  this.pod     = options.pod;\n  this.options = options;\n  this.hasPathToken = hasPathToken(this.files());\n\n  podDeprecations(this.project.config(), ui);\n\n  ui.writeLine('installing ' + this.name);\n\n  if (dryRun) {\n    ui.writeLine(chalk.yellow('You specified the dry-run flag, so no' +\n      ' changes will be written.'));\n  }\n\n  this._normalizeEntityName(options.entity);\n  this._checkForPod(options.verbose);\n  this._checkInRepoAddonExists(options.inRepoAddon);\n\n  debug('START: processing blueprint: `%s`', this.name);\n  var start = new Date();\n  return this._process(\n    options,\n    this.beforeInstall,\n    this.processFiles,\n    this.afterInstall).finally(function() {\n      debug('END: processing blueprint: `%s` in (%dms)', this.name, new Date() - start);\n    }.bind(this));\n};\n\n/**\n  @method uninstall\n  @param {Object} options\n  @return {Promise}\n*/\nBlueprint.prototype.uninstall = function(options) {\n  var ui       = this.ui     = options.ui;\n  var dryRun   = this.dryRun = options.dryRun;\n  this.project = options.project;\n  this.pod     = options.pod;\n  this.options = options;\n  this.hasPathToken = hasPathToken(this.files());\n\n  podDeprecations(this.project.config(), ui);\n\n  ui.writeLine('uninstalling ' + this.name);\n\n  if (dryRun) {\n    ui.writeLine(chalk.yellow('You specified the dry-run flag, so no' +\n      ' files will be deleted.'));\n  }\n\n  this._normalizeEntityName(options.entity);\n  this._checkForPod(options.verbose);\n\n  return this._process(\n    options,\n    this.beforeUninstall,\n    this.processFilesForUninstall,\n    this.afterUninstall);\n};\n\n/**\n  Hook for running operations before install.\n  @method beforeInstall\n  @return {Promise|null}\n*/\nBlueprint.prototype.beforeInstall = function() {};\n\n/**\n  Hook for running operations after install.\n  @method afterInstall\n  @return {Promise|null}\n*/\nBlueprint.prototype.afterInstall = function() {};\n\n/**\n  Hook for running operations before uninstall.\n  @method beforeUninstall\n  @return {Promise|null}\n*/\nBlueprint.prototype.beforeUninstall = function() {};\n\n/**\n  Hook for running operations after uninstall.\n  @method afterUninstall\n  @return {Promise|null}\n*/\nBlueprint.prototype.afterUninstall = function() {};\n\n/**\n  Hook for adding additional locals\n  @method locals\n  @return {Object|null}\n*/\nBlueprint.prototype.locals = function() {};\n\n/**\n  Hook to add additional or override existing fileMapTokens.\n  @method fileMapTokens\n  @return {Object|null}\n*/\nBlueprint.prototype.fileMapTokens = function() {\n};\n\n/**\n  @private\n  @method _fileMapTokens\n  @param {Object} options\n  @return {Object}\n*/\nBlueprint.prototype._fileMapTokens = function(options) {\n  var standardTokens = {\n    __name__: function(options) {\n      if (options.pod && options.hasPathToken) {\n        return options.blueprintName;\n      }\n      return options.dasherizedModuleName;\n    },\n    __path__: function(options) {\n      var blueprintName = options.blueprintName;\n\n      if (blueprintName.match(/-test/)) {\n        blueprintName = options.blueprintName.slice(0, options.blueprintName.indexOf('-test'));\n      }\n      if (options.pod && options.hasPathToken) {\n        return path.join(options.podPath, options.dasherizedModuleName);\n      }\n      return inflector.pluralize(blueprintName);\n    },\n    __root__: function(options) {\n      if (options.inRepoAddon) {\n        return path.join('lib',options.inRepoAddon, 'addon');\n      }\n      if (options.inDummy) {\n        return path.join('tests','dummy','app');\n      }\n      if (options.inAddon) {\n        return 'addon';\n      }\n      return 'app';\n    },\n    __test__: function(options) {\n      if (options.pod && options.hasPathToken) {\n        return options.blueprintName;\n      }\n      return options.dasherizedModuleName + '-test';\n    }\n  };\n\n  var customTokens = this.fileMapTokens(options) || options.fileMapTokens || {};\n  return merge(standardTokens, customTokens);\n};\n\n/**\n  Used to generate fileMap tokens for mapFile.\n\n  @method generateFileMap\n  @param {Object} fileMapVariables\n  @return {Object}\n*/\nBlueprint.prototype.generateFileMap = function(fileMapVariables) {\n  var tokens        = this._fileMapTokens(fileMapVariables);\n  var fileMapValues = values(tokens);\n  var tokenValues   = fileMapValues.map(function(token) { return token(fileMapVariables); });\n  var tokenKeys     = keys(tokens);\n  return zipObject(tokenKeys,tokenValues);\n};\n\n/**\n  @method buildFileInfo\n  @param {Function} destPath\n  @param {Object} templateVariables\n  @param {String} file\n  @return {FileInfo}\n*/\nBlueprint.prototype.buildFileInfo = function(destPath, templateVariables, file) {\n  var mappedPath = this.mapFile(file, templateVariables);\n\n  return new FileInfo({\n    action: 'write',\n    outputPath: destPath(mappedPath),\n    displayPath: path.normalize(mappedPath),\n    inputPath: this.srcPath(file),\n    templateVariables: templateVariables,\n    ui: this.ui\n  });\n};\n\n/**\n  @method isUpdate\n  @return {Boolean}\n*/\nBlueprint.prototype.isUpdate = function() {\n  if (this.project && this.project.isEmberCLIProject) {\n    return this.project.isEmberCLIProject();\n  }\n};\n\n/**\n  @private\n  @method _getFileInfos\n  @param {Array} files\n  @param {String} intoDir\n  @param {Object} templateVariables\n  @return {Array} file infos\n*/\nBlueprint.prototype._getFileInfos = function(files, intoDir, templateVariables) {\n  return files.map(this.buildFileInfo.bind(this, destPath.bind(null, intoDir), templateVariables));\n};\n\n/**\n  Add update files to ignored files\n  @private\n  @method _ignoreUpdateFiles\n*/\nBlueprint.prototype._ignoreUpdateFiles = function() {\n  if (this.isUpdate()) {\n    Blueprint.ignoredFiles = Blueprint.ignoredFiles.concat(Blueprint.ignoredUpdateFiles);\n  }\n};\n\n/**\n  @private\n  @method _getFilesForInstall\n  @param {Array} targetFiles\n  @return {Array} files\n*/\nBlueprint.prototype._getFilesForInstall = function(targetFiles) {\n  var files = this.files();\n\n  // if we've defined targetFiles, get file info on ones that match\n  return targetFiles && targetFiles.length > 0 && intersect(files, targetFiles) || files;\n};\n\n/**\n  @private\n  @method _checkForNoMatch\n  @param {Array} fileInfos\n  @param {String} rawArgs\n*/\nBlueprint.prototype._checkForNoMatch = function(fileInfos, rawArgs) {\n  if (fileInfos.filter(isFilePath).length < 1 && rawArgs) {\n    this.ui.writeLine(chalk.yellow('The globPattern \\\"' + rawArgs +\n      '\\\" did not match any files, so no file updates will be made.'));\n  }\n};\n\nfunction finishProcessingForInstall(infos) {\n  infos.forEach(markIdenticalToBeSkipped);\n\n  var infosNeedingConfirmation = infos.reduce(gatherConfirmationMessages, []);\n\n  return sequence(infosNeedingConfirmation).returns(infos);\n}\n\nfunction finishProcessingForUninstall(infos) {\n  infos.forEach(markToBeRemoved);\n  return infos;\n}\n\n/**\n  @method processFiles\n  @param {String} intoDir\n  @param {Object} templateVariables\n*/\nBlueprint.prototype.processFiles = function(intoDir, templateVariables) {\n  var files = this._getFilesForInstall(templateVariables.targetFiles);\n  var fileInfos = this._getFileInfos(files, intoDir, templateVariables);\n  this._checkForNoMatch(fileInfos, templateVariables.rawArgs);\n\n  this._ignoreUpdateFiles();\n\n  return Promise.filter(fileInfos, isValidFile).\n    map(prepareConfirm).\n    then(finishProcessingForInstall);\n};\n\n/**\n  @method processFilesForUninstall\n  @param {String} intoDir\n  @param {Object} templateVariables\n*/\nBlueprint.prototype.processFilesForUninstall = function(intoDir, templateVariables) {\n  var fileInfos = this._getFileInfos(this.files(), intoDir, templateVariables);\n\n  this._ignoreUpdateFiles();\n\n  return Promise.filter(fileInfos, isValidFile).\n    then(finishProcessingForUninstall);\n};\n\n\n/**\n  @method mapFile\n  @param {String} file\n  @return {String}\n*/\nBlueprint.prototype.mapFile = function(file, locals) {\n  var pattern, i;\n  var fileMap = locals.fileMap || { __name__: locals.dasherizedModuleName };\n  file = Blueprint.renamedFiles[file] || file;\n  for (i in fileMap) {\n    pattern = new RegExp(i, 'g');\n    file = file.replace(pattern, fileMap[i]);\n  }\n  return file;\n};\n\n/**\n  Looks for a __root__ token in the files folder. Must be present for\n  the blueprint to support addon tokens. The `server`, `blueprints`, and `test`\n\n  @private\n  @method supportsAddon\n  @return {Boolean}\n*/\nBlueprint.prototype.supportsAddon = function() {\n  return this.files().join().match(/__root__/);\n};\n\n/**\n  @private\n  @method _generateFileMapVariables\n  @param {Object} options\n  @return {Object}\n*/\nBlueprint.prototype._generateFileMapVariables = function(moduleName, locals, options) {\n  var originBlueprintName = options.originBlueprintName || this.name;\n  var podModulePrefix = this.project.config().podModulePrefix || '';\n  var podPath = podModulePrefix.substr(podModulePrefix.lastIndexOf('/') + 1);\n  var inAddon = this.project.isEmberCLIAddon() || !!options.inRepoAddon;\n  var inDummy = this.project.isEmberCLIAddon() ? options.dummy : false;\n\n  return {\n    pod: this.pod,\n    podPath: podPath,\n    hasPathToken: this.hasPathToken,\n    inAddon: inAddon,\n    inRepoAddon: options.inRepoAddon,\n    inDummy: inDummy,\n    blueprintName: this.name,\n    originBlueprintName: originBlueprintName,\n    dasherizedModuleName: stringUtils.dasherize(moduleName),\n    locals: locals\n  };\n};\n\n/**\n  @private\n  @method _locals\n  @param {Object} options\n  @return {Object}\n*/\nBlueprint.prototype._locals = function(options) {\n  var packageName = options.project.name();\n  var moduleName = options.entity && options.entity.name || packageName;\n  var sanitizedModuleName = moduleName.replace(/\\//g, '-');\n\n  return new Promise(function(resolve) {\n    resolve(this.locals(options));\n  }.bind(this)).then(function (customLocals) {\n    var fileMapVariables = this._generateFileMapVariables(moduleName, customLocals, options);\n    var fileMap = this.generateFileMap(fileMapVariables);\n    var standardLocals = {\n      dasherizedPackageName: stringUtils.dasherize(packageName),\n      classifiedPackageName: stringUtils.classify(packageName),\n      dasherizedModuleName: stringUtils.dasherize(moduleName),\n      classifiedModuleName: stringUtils.classify(sanitizedModuleName),\n      camelizedModuleName: stringUtils.camelize(sanitizedModuleName),\n      decamelizedModuleName: stringUtils.decamelize(sanitizedModuleName),\n      fileMap: fileMap,\n      hasPathToken: this.hasPathToken,\n      targetFiles: options.targetFiles,\n      rawArgs: options.rawArgs\n    };\n\n    return merge({}, standardLocals, customLocals);\n  }.bind(this));\n};\n\n/**\n  Used to add a package to the project's `package.json`.\n\n  Generally, this would be done from the `afterInstall` hook, to\n  ensure that a package that is required by a given blueprint is\n  available.\n\n  @method addPackageToProject\n  @param {String} packageName\n  @param {String} target\n  @return {Promise}\n*/\nBlueprint.prototype.addPackageToProject = function(packageName, target) {\n  var packageObject = {name: packageName};\n\n  if (target) {\n    packageObject.target = target;\n  }\n\n  return this.addPackagesToProject([packageObject]);\n};\n\n/**\n  Used to add multiple packages to the project's `package.json`.\n\n  Generally, this would be done from the `afterInstall` hook, to\n  ensure that a package that is required by a given blueprint is\n  available.\n\n  Expects each array item to be an object with a `name`.  Each object\n  may optionally have a `target` to specify a specific version.\n\n  @method addPackagesToProject\n  @param {Array} packages\n  @return {Promise}\n*/\nBlueprint.prototype.addPackagesToProject = function(packages) {\n  var task = this.taskFor('npm-install');\n  var installText = (packages.length > 1) ? 'install packages' : 'install package';\n  var packageNames = [];\n  var packageArray = [];\n\n  for (var i = 0; i < packages.length; i++) {\n    packageNames.push(packages[i].name);\n\n    var packageNameAndVersion = packages[i].name;\n\n    if (packages[i].target) {\n      packageNameAndVersion += '@' + packages[i].target;\n    }\n\n    packageArray.push(packageNameAndVersion);\n  }\n\n  this._writeStatusToUI(chalk.green, installText, packageNames.join(', '));\n\n  return task.run({\n    'save-dev': true,\n    verbose: false,\n    packages: packageArray\n  });\n};\n\n/**\n  Used to remove a package from the project's `package.json`.\n\n  Generally, this would be done from the `afterInstall` hook, to\n  ensure that any package conflicts can be resolved before the\n  addon is used.\n\n  @method removePackageFromProject\n  @param {String} packageName\n  @return {Promise}\n*/\nBlueprint.prototype.removePackageFromProject = function(packageName) {\n  var packageObject = {name: packageName};\n\n  return this.removePackagesFromProject([packageObject]);\n};\n\n/**\n  Used to remove multiple packages from the project's `package.json`.\n\n  Generally, this would be done from the `afterInstall` hook, to\n  ensure that any package conflicts can be resolved before the\n  addon is used.\n\n  Expects each array item to be an object with a `name` property.\n\n  @method removePackagesFromProject\n  @param {Array} packages\n  @return {Promise}\n*/\nBlueprint.prototype.removePackagesFromProject = function(packages) {\n  var task = this.taskFor('npm-uninstall');\n  var installText = (packages.length > 1) ? 'uninstall packages' : 'uninstall package';\n  var packageNames = [];\n  var packageArray = [];\n\n  for (var i = 0; i < packages.length; i++) {\n    packageNames.push(packages[i].name);\n\n    var packageNameAndVersion = packages[i].name;\n\n    packageArray.push(packageNameAndVersion);\n  }\n\n  this._writeStatusToUI(chalk.green, installText, packageNames.join(', '));\n\n  return task.run({\n    'save-dev': true,\n    verbose: false,\n    packages: packageArray\n  });\n};\n\n\n/**\n  Used to retrieve a task with the given name. Passes the new task\n  the standard information available (like `ui`, `analytics`, `project`, etc).\n\n  @method taskFor\n  @param dasherizedName\n  @public\n*/\nBlueprint.prototype.taskFor = function(dasherizedName) {\n  var Task = require('../tasks/' + dasherizedName);\n\n  return new Task({\n    ui: this.ui,\n    project: this.project\n  });\n};\n\n/*\n\n  Inserts the given content into a file. If the `contentsToInsert` string is already\n  present in the current contents, the file will not be changed unless `force` option\n  is passed.\n\n  If `options.before` is specified, `contentsToInsert` will be inserted before\n  the first instance of that string.  If `options.after` is specified, the\n  contents will be inserted after the first instance of that string.\n  If the string specified by options.before or options.after is not in the file,\n  no change will be made.\n\n  If neither `options.before` nor `options.after` are present, `contentsToInsert`\n  will be inserted at the end of the file.\n\n  Example:\n  ```\n  // app/router.js\n  Router.map(function() {\n  });\n\n  insertIntoFile('app/router.js',\n                 '  this.route(\"admin\");',\n                 {after:'Router.map(function() {'+EOL});\n\n  // new app/router.js\n  Router.map(function() {\n    this.route(\"admin\");\n  });\n  ```\n\n  @method insertIntoFile\n  @param {String} pathRelativeToProjectRoot\n  @param {String} contentsToInsert\n  @param {Object} options\n  @return {Promise}\n*/\nBlueprint.prototype.insertIntoFile = function(pathRelativeToProjectRoot, contentsToInsert, providedOptions) {\n  var fullPath          = path.join(this.project.root, pathRelativeToProjectRoot);\n  var originalContents  = '';\n\n  if (existsSync(fullPath)) {\n    originalContents = fs.readFileSync(fullPath, { encoding: 'utf8' });\n  }\n\n  var contentsToWrite   = originalContents;\n\n  var options           = providedOptions || {};\n  var alreadyPresent    = originalContents.indexOf(contentsToInsert) > -1;\n  var insert            = !alreadyPresent;\n  var insertBehavior    = 'end';\n\n  if (options.before) { insertBehavior = 'before'; }\n  if (options.after)  { insertBehavior = 'after'; }\n\n  if (options.force) { insert = true; }\n\n  if (insert) {\n    if (insertBehavior === 'end') {\n      contentsToWrite += contentsToInsert;\n    } else {\n      var contentMarker      = options[insertBehavior];\n      var contentMarkerIndex = contentsToWrite.indexOf(contentMarker);\n\n      if (contentMarkerIndex !== -1) {\n        var insertIndex = contentMarkerIndex;\n        if (insertBehavior === 'after') { insertIndex += contentMarker.length; }\n\n        contentsToWrite = contentsToWrite.slice(0, insertIndex) +\n                          contentsToInsert + EOL +\n                          contentsToWrite.slice(insertIndex);\n      }\n    }\n  }\n\n  var returnValue = {\n    path: fullPath,\n    originalContents: originalContents,\n    contents: contentsToWrite,\n    inserted: false\n  };\n\n  if (contentsToWrite !== originalContents) {\n    returnValue.inserted = true;\n\n    return writeFile(fullPath, contentsToWrite)\n      .then(function() {\n        return returnValue;\n      });\n  } else {\n    return Promise.resolve(returnValue);\n  }\n};\n\nBlueprint.prototype._printCommand = printCommand;\n\nBlueprint.prototype.printBasicHelp = function(verbose) {\n  var initialMargin = '      ';\n  var output = initialMargin;\n  if (this.overridden) {\n    output += chalk.grey('(overridden) ' + this.name);\n  } else {\n    output += this.name;\n\n    output += this._printCommand(initialMargin, true);\n\n    if (verbose) {\n      output += EOL + this.printDetailedHelp(this.availableOptions);\n    }\n  }\n\n  return output;\n};\n\nBlueprint.prototype.printDetailedHelp = function() {\n  return '';\n};\n\nBlueprint.prototype.getJson = function(verbose) {\n  var json = {};\n\n  printableProperties.forEachWithProperty(function(key) {\n    var value = this[key];\n    if (key === 'availableOptions') {\n      value = cloneDeep(value);\n      value.forEach(function(option) {\n        if (typeof option.type === 'function') {\n          option.type = option.type.name;\n        }\n      });\n    }\n    json[key] = value;\n  }, this);\n\n  if (verbose) {\n    var detailedHelp = this.printDetailedHelp(this.availableOptions);\n    if (detailedHelp) {\n      json.detailedHelp = detailedHelp;\n    }\n  }\n\n  return json;\n};\n\n/**\n  Used to retrieve a blueprint with the given name.\n\n  @method lookupBlueprint\n  @param dasherizedName\n  @public\n*/\nBlueprint.prototype.lookupBlueprint = function(dasherizedName) {\n  var projectPaths = this.project ? this.project.blueprintLookupPaths() : [];\n\n  return Blueprint.lookup(dasherizedName, {\n    paths: projectPaths\n  });\n};\n\n/**\n  @static\n  @method lookup\n  @namespace Blueprint\n  @param {String} [name]\n  @param {Object} [options]\n  @param {Array} [options.paths] Extra paths to search for blueprints\n  @param {Object} [options.properties] Properties\n  @return {Blueprint}\n*/\nBlueprint.lookup = function(name, options) {\n  options = options || {};\n\n  var lookupPaths = generateLookupPaths(options.paths);\n\n  var lookupPath;\n  var blueprintPath;\n\n  for (var i = 0; (lookupPath = lookupPaths[i]); i++) {\n    blueprintPath = path.resolve(lookupPath, name);\n\n    if (existsSync(blueprintPath)) {\n      return Blueprint.load(blueprintPath);\n    }\n  }\n\n  if (!options.ignoreMissing) {\n    throw new SilentError('Unknown blueprint: ' + name);\n  }\n};\n\n/**\n  Loads a blueprint from given path.\n  @static\n  @method load\n  @namespace Blueprint\n  @param {String} blueprintPath\n  @return {Blueprint} blueprint instance\n*/\nBlueprint.load = function(blueprintPath) {\n  var constructorPath = path.join(path.resolve(blueprintPath), 'index');\n  var blueprintModule;\n  var Constructor = Blueprint;\n\n  if (fs.lstatSync(blueprintPath).isDirectory()) {\n    blueprintModule = require(constructorPath);\n    if (blueprintModule) {\n      if (typeof blueprintModule === 'function') {\n        Constructor = blueprintModule;\n      } else if (typeof blueprintModule.default === 'function') {\n        Constructor = blueprintModule.default\n      } else {\n        Constructor = Blueprint.extend(blueprintModule);\n      }\n    }\n\n    return new Constructor(blueprintPath);\n  }\n\n  return;\n};\n\n/**\n  @static\n  @method list\n  @namespace Blueprint\n  @param {Object} [options]\n  @param {Array} [options.paths] Extra paths to search for blueprints\n  @return {Blueprint}\n*/\nBlueprint.list = function(options) {\n  options = options || {};\n\n  var lookupPaths = generateLookupPaths(options.paths);\n  var seen = [];\n\n  return lookupPaths.map(function(lookupPath) {\n    var blueprints = dir(lookupPath);\n    var packagePath = path.join(lookupPath, '../package.json');\n    var source;\n\n    if (existsSync(packagePath)) {\n      source = require(packagePath).name;\n    } else {\n      source = path.basename(path.join(lookupPath, '..'));\n    }\n\n    blueprints = blueprints.map(function(blueprintPath) {\n      var blueprint = Blueprint.load(blueprintPath);\n      var name;\n\n      if (blueprint) {\n        name = blueprint.name;\n        blueprint.overridden = includes(seen, name);\n        seen.push(name);\n\n        return blueprint;\n      }\n\n      return;\n    });\n\n    return {\n      source: source,\n      blueprints: compact(blueprints)\n    };\n  });\n};\n\n/**\n  @static\n  @property renameFiles\n*/\nBlueprint.renamedFiles = {\n  'gitignore': '.gitignore'\n};\n\n/**\n  @static\n  @property ignoredFiles\n*/\nBlueprint.ignoredFiles = [\n  '.DS_Store'\n];\n\n/**\n  @static\n  @property ignoredUpdateFiles\n*/\nBlueprint.ignoredUpdateFiles = [\n  '.gitkeep',\n  'app.css'\n];\n\n/**\n  @static\n  @property defaultLookupPaths\n*/\nBlueprint.defaultLookupPaths = function() {\n  return [\n    path.resolve(__dirname, '..', '..', 'blueprints')\n  ];\n};\n\n/**\n  @private\n  @method prepareConfirm\n  @param {FileInfo} info\n  @return {Promise}\n*/\nfunction prepareConfirm(info) {\n  return info.checkForConflict().then(function(resolution) {\n    info.resolution = resolution;\n    return info;\n  });\n}\n\n/**\n  @private\n  @method markIdenticalToBeSkipped\n  @param {FileInfo} info\n*/\nfunction markIdenticalToBeSkipped(info) {\n  if (info.resolution === 'identical') {\n    info.action = 'skip';\n  }\n}\n\n/**\n  @private\n  @method markToBeRemoved\n  @param {FileInfo} info\n*/\nfunction markToBeRemoved(info) {\n  info.action = 'remove';\n}\n\n/**\n  @private\n  @method gatherConfirmationMessages\n  @param {Array} collection\n  @param {FileInfo} info\n  @return {Array}\n*/\nfunction gatherConfirmationMessages(collection, info) {\n  if (info.resolution === 'confirm') {\n    collection.push(info.confirmOverwriteTask());\n  }\n  return collection;\n}\n\n/**\n  @private\n  @method isFile\n  @param {FileInfo} info\n  @return {Boolean}\n*/\nfunction isFile(info) {\n  return stat(info.inputPath).invoke('isFile');\n}\n\n/**\n  @private\n  @method isIgnored\n  @param {FileInfo} info\n  @return {Boolean}\n*/\nfunction isIgnored(info) {\n  var fn = info.inputPath;\n\n  return any(Blueprint.ignoredFiles, function(ignoredFile) {\n    return minimatch(fn, ignoredFile, { matchBase: true });\n  });\n}\n\n/**\n  Combines provided lookup paths with defaults and removes\n  duplicates.\n\n  @private\n  @method generateLookupPaths\n  @param {Array} lookupPaths\n  @return {Array}\n*/\nfunction generateLookupPaths(lookupPaths) {\n  lookupPaths = lookupPaths || [];\n  lookupPaths = lookupPaths.concat(Blueprint.defaultLookupPaths());\n  return uniq(lookupPaths);\n}\n\n/**\n  Looks for a __path__ token in the files folder. Must be present for\n  the blueprint to support pod tokens.\n\n  @private\n  @method hasPathToken\n  @param {files} files\n  @return {Boolean}\n*/\nfunction hasPathToken(files) {\n  return files.join().match(/__path__/);\n}\n\nfunction inRepoAddonExists(name, root) {\n  var addonPath = path.join(root, 'lib', name);\n  return existsSync(addonPath);\n}\n\nfunction podDeprecations(config, ui) {\n  /*\n  var podModulePrefix = config.podModulePrefix || '';\n  var podPath = podModulePrefix.substr(podModulePrefix.lastIndexOf('/') + 1);\n  // Disabled until we are ready to deprecate podModulePrefix\n  deprecateUI(ui)('`podModulePrefix` is deprecated and will be removed from future versions of ember-cli.'+\n    ' Please move existing pods from \\'app/' + podPath + '/\\' to \\'app/\\'.', config.podModulePrefix);\n  */\n  if (config.usePodsByDefault) {\n    ui.writeDeprecateLine('`usePodsByDefault` is no longer supported in \\'config/environment.js\\',' +\n      ' use `usePods` in \\'.ember-cli\\' instead.');\n  }\n}\n\n/**\n  @private\n  @method destPath\n  @param {String} intoDir\n  @param {String} file\n  @return {String} new path\n*/\nfunction destPath(intoDir, file) {\n  return path.join(intoDir, file);\n}\n\n/**\n  @private\n  @method isValidFile\n  @param {Object} fileInfo\n  @return {Promise}\n*/\nfunction isValidFile(fileInfo) {\n  if (isIgnored(fileInfo)) {\n    return Promise.resolve(false);\n  } else {\n    return isFile(fileInfo);\n  }\n}\n\n/**\n  @private\n  @method isFilePath\n  @param {Object} fileInfo\n  @return {Promise}\n*/\nfunction isFilePath(fileInfo) {\n  return fs.statSync(fileInfo.inputPath).isFile();\n}\n\n/**\n @private\n @method dir\n @returns {Array} list of files in the given directory or and empty array if no directory exists\n*/\nfunction dir(fullPath) {\n  if (existsSync(fullPath)) {\n    return fs.readdirSync(fullPath).map(function(fileName) {\n      return path.join(fullPath, fileName);\n    });\n  } else {\n    return [];\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/models/file-info.js":"'use strict';\n\nvar fs           = require('fs');\nvar Promise      = require('../ext/promise');\nvar readFile     = Promise.denodeify(fs.readFile);\nvar lstat        = Promise.denodeify(fs.stat);\nvar chalk        = require('chalk');\nvar EditFileDiff = require('./edit-file-diff');\nvar EOL          = require('os').EOL;\nvar isBinaryFile = require('isbinaryfile');\nvar template     = require('lodash/template');\nvar canEdit      = require('../utilities/open-editor').canEdit;\n\nfunction processTemplate(content, context) {\n  var options = {\n    evaluate:    /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape:      /<%-([\\s\\S]+?)%>/g\n  };\n  return template(content, options)(context);\n}\n\nfunction diffHighlight(line) {\n  if (line[0] === '+') {\n    return chalk.green(line);\n  } else if (line[0] === '-') {\n    return chalk.red(line);\n  } else if (line.match(/^@@/)) {\n    return chalk.cyan(line);\n  } else {\n    return line;\n  }\n}\n\nFileInfo.prototype.confirmOverwrite = function(path) {\n  var promptOptions = {\n    type: 'expand',\n    name: 'answer',\n    default: false,\n    message: chalk.red('Overwrite') + ' ' + path + '?',\n    choices: [\n      { key: 'y', name: 'Yes, overwrite', value: 'overwrite' },\n      { key: 'n', name: 'No, skip', value: 'skip' },\n      { key: 'd', name: 'Diff', value: 'diff' }\n    ]\n  };\n\n  if (canEdit()) {\n    promptOptions.choices.push({ key: 'e', name: 'Edit', value: 'edit' });\n  }\n\n  return this.ui.prompt(promptOptions)\n    .then(function(response) {\n      return response.answer;\n    });\n};\n\nFileInfo.prototype.displayDiff = function() {\n  var info = this,\n      jsdiff = require('diff');\n  return Promise.hash({\n    input: this.render(),\n    output: readFile(info.outputPath)\n  }).then(function(result) {\n    var diff = jsdiff.createPatch(\n      info.outputPath, result.output.toString(), result.input\n    );\n    var lines = diff.split('\\n');\n\n    for (var i = 0; i < lines.length; i++) {\n      info.ui.write(\n        diffHighlight(lines[i] + EOL)\n      );\n    }\n  });\n};\n\nfunction FileInfo(options) {\n  this.action = options.action;\n  this.outputPath = options.outputPath;\n  this.displayPath = options.displayPath;\n  this.inputPath =  options.inputPath;\n  this.templateVariables = options.templateVariables;\n  this.ui = options.ui;\n}\n\nFileInfo.prototype.render = function() {\n  var path = this.inputPath,\n      context = this.templateVariables;\n  if (!this.rendered) {\n    this.rendered = readFile(path).then(function(content) {\n      return lstat(path).then(function(fileStat) {\n        if (isBinaryFile(content, fileStat.size)) {\n          return content;\n        } else {\n          try {\n            return processTemplate(content.toString(), context);\n          } catch (err) {\n            err.message += ' (Error in blueprint template: ' + path + ')';\n            throw err;\n          }\n        }\n      });\n    });\n  }\n  return this.rendered;\n};\n\nFileInfo.prototype.checkForConflict = function() {\n  return new Promise(function (resolve, reject) {\n    fs.exists(this.outputPath, function (doesExist, error) {\n      if (error) {\n        reject(error);\n        return;\n      }\n\n      var result;\n\n      if (doesExist) {\n        result = Promise.hash({\n          input: this.render(),\n          output: readFile(this.outputPath)\n        }).then(function(result) {\n          var type;\n          if (result.input === result.output.toString()) {\n            type = 'identical';\n          } else {\n            type = 'confirm';\n          }\n          return type;\n        }.bind(this));\n      } else {\n        result = 'none';\n      }\n\n      resolve(result);\n    }.bind(this));\n  }.bind(this));\n};\n\nFileInfo.prototype.confirmOverwriteTask = function() {\n  var info = this;\n\n  return function() {\n    return new Promise(function(resolve, reject) {\n      function doConfirm() {\n        info.confirmOverwrite(info.displayPath).then(function(action) {\n          if (action === 'diff') {\n            info.displayDiff().then(doConfirm, reject);\n          } else if (action === 'edit') {\n            var editFileDiff = new EditFileDiff({info: info});\n            editFileDiff.edit().then(function() {\n              info.action = action;\n              resolve(info);\n            }).catch(function() {\n              doConfirm()\n                .finally(function() {\n                  resolve(info);\n                });\n            });\n          } else {\n            info.action = action;\n            resolve(info);\n          }\n        }, reject);\n      }\n\n      doConfirm();\n    });\n  }.bind(this);\n};\n\nmodule.exports = FileInfo;\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/models/edit-file-diff.js":"'use strict';\n\nvar fs           = require('fs');\nvar Promise      = require('../ext/promise');\nvar readFile     = Promise.denodeify(fs.readFile);\nvar writeFile    = Promise.denodeify(fs.writeFile);\nvar jsdiff       = require('diff');\nvar temp         = require('temp').track();\nvar path         = require('path');\nvar SilentError  = require('silent-error');\nvar openEditor   = require('../utilities/open-editor');\n\nfunction EditFileDiff(options) {\n  this.info = options.info;\n}\n\nEditFileDiff.prototype.edit = function() {\n  return Promise.hash({\n    input:  this.info.render(),\n    output: readFile(this.info.outputPath)\n  })\n    .then(invokeEditor.bind(this))\n    .then(applyPatch.bind(this))\n    .finally(cleanUp.bind(this));\n};\n\nfunction cleanUp() {\n  temp.cleanupSync();\n}\n\nfunction applyPatch(resultHash) {\n  /*jshint validthis:true */\n  return Promise.hash({\n    diffString: readFile(resultHash.diffPath),\n    currentString: readFile(resultHash.outputPath)\n  }).then(function(result) {\n    var appliedDiff = jsdiff.applyPatch(result.currentString.toString(), result.diffString.toString());\n\n    if (!appliedDiff) {\n      var message = 'Patch was not cleanly applied.';\n      this.info.ui.writeLine(message + ' Please choose another action.');\n      throw new SilentError(message);\n    }\n\n    return writeFile(resultHash.outputPath, appliedDiff);\n  }.bind(this));\n}\n\nfunction invokeEditor(result) {\n  var info     = this.info; // jshint ignore:line\n  var diff     = jsdiff.createPatch(info.outputPath, result.output.toString(), result.input);\n  var diffPath = path.join(temp.mkdirSync(), 'currentDiff.diff');\n\n  return writeFile(diffPath, diff).then(function() {\n    return openEditor(diffPath);\n  }).then(function() {\n    return { outputPath: info.outputPath, diffPath: diffPath };\n  });\n}\n\nmodule.exports = EditFileDiff;\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/utilities/open-editor.js":"'use strict';\n\nvar Promise = require('../ext/promise');\nvar spawn = require('child_process').spawn;\n\nfunction openEditor(file) {\n  if (!openEditor.canEdit()) {\n    throw new Error('EDITOR environment variable is not set');\n  }\n\n  if (!file) {\n    throw new Error('No `file` option provided');\n  }\n\n  var editorArgs  = openEditor._env().EDITOR.split(' ');\n  var editor      = editorArgs.shift();\n  var editProcess = openEditor._spawn(editor, [file].concat(editorArgs), {stdio: 'inherit'});\n\n  return new Promise(function(resolve, reject) {\n    editProcess.on('close', function (code) {\n      if (code === 0) {\n        resolve();\n      } else {\n        reject();\n      }\n    });\n  });\n}\n\nopenEditor.canEdit = function() {\n  return openEditor._env().EDITOR !== undefined;\n};\n\nopenEditor._env = function() {\n  return process.env;\n};\n\nopenEditor._spawn = function() {\n  return spawn.apply(this, arguments);\n};\n\nmodule.exports = openEditor;\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/utilities/sequence.js":"'use strict';\n\nvar Promise = require('../ext/promise');\n/*\n *\n * given an array of functions, that may or may not return promises sequence\n * will invoke them sequentially. If a promise is encountered sequence will\n * wait until it fulfills before moving to the next entry.\n *\n * ```js\n * var tasks = [\n *   function() { return Promise.resolve(1); },\n *   2,\n *   function() { return timeout(1000).then(function() { return 3; } },\n * ];\n *\n * sequence(tasks).then(function(results) {\n *   results === [\n *     1,\n *     2,\n *     3\n *   ]\n * });\n * ```\n *\n * @method sequence\n * @param tasks\n * @return Promise<Array>\n *\n */\nmodule.exports = function sequence(tasks) {\n  var length = tasks.length;\n  var current = Promise.resolve();\n  var results = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    current = results[i] = current.then(tasks[i]);\n  }\n\n  return Promise.all(results);\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/utilities/parse-options.js":"'use strict';\n\nvar reduce = require('lodash/reduce');\n\nmodule.exports = function parseOptions(args) {\n  return reduce(args, function(result, arg) {\n    var parts = arg.split(':');\n    result[parts[0]] = parts.slice(1).join(':');\n    return result;\n  }, {});\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/tasks/git-init.js":"'use strict';\n\nvar Promise  = require('../../lib/ext/promise');\nvar Task     = require('../models/task');\nvar exec     = Promise.denodeify(require('child_process').exec);\nvar path     = require('path');\nvar pkg      = require('../../../package.json');\nvar fs       = require('fs');\nvar template = require('lodash/template');\n\nvar gitEnvironmentVariables = {\n  GIT_AUTHOR_NAME: 'Tomster',\n  GIT_AUTHOR_EMAIL: 'tomster@emberjs.com',\n  get GIT_COMMITTER_NAME() { return this.GIT_AUTHOR_NAME; },\n  get GIT_COMMITTER_EMAIL() { return this.GIT_AUTHOR_EMAIL; }\n};\n\nmodule.exports = Task.extend({\n  run: function(commandOptions) {\n    var chalk  = require('chalk');\n    var ui     = this.ui;\n\n    if (commandOptions.skipGit) {\n      return Promise.resolve();\n    }\n\n    return exec('git --version')\n      .then(function() {\n        return exec('git init')\n          .then(function() {\n            return exec('git add .');\n          })\n          .then(function() {\n            var commitTemplate = fs.readFileSync(path.join(__dirname, '../utilities/COMMIT_MESSAGE.txt'));\n            var commitMessage = template(commitTemplate)(pkg);\n            return exec('git commit -m \"' + commitMessage + '\"', {env: gitEnvironmentVariables});\n          })\n          .then(function() {\n            ui.writeLine(chalk.green('Successfully initialized git.'));\n          });\n      })\n      .catch(function(error) {\n        if (commandOptions.logErrors) {\n          ui.writeError(error);\n        }\n        // if git is not found or an error was thrown during the `git`\n        // init process just swallow any errors here\n      });\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/tasks/install-blueprint.js":"'use strict';\n\nvar Blueprint     = require('../models/blueprint');\nvar Task          = require('../models/task');\nvar Promise       = require('../ext/promise');\nvar temp          = require('temp');\nvar childProcess  = require('child_process');\nvar path          = require('path');\nvar merge         = require('lodash/merge');\n\nvar mkdir = Promise.denodeify(temp.mkdir);\nvar exec = Promise.denodeify(childProcess.exec);\n\nmodule.exports = Task.extend({\n  run: function(options) {\n    var cwd             = process.cwd();\n    var name            = options.rawName;\n    var blueprintOption = options.blueprint;\n    // If we're in a dry run, pretend we changed directories.\n    // Pretending we cd'd avoids prompts in the actual current directory.\n    var fakeCwd         = path.join(cwd, name);\n    var target          = options.dryRun ? fakeCwd : cwd;\n\n    var installOptions = {\n      target: target,\n      entity: { name: name },\n      ui: this.ui,\n      project: this.project,\n      dryRun: options.dryRun,\n      targetFiles: options.targetFiles,\n      rawArgs: options.rawArgs\n    };\n\n    installOptions = merge(installOptions, options || {});\n\n    var blueprintName = blueprintOption || 'app';\n    var blueprint = Blueprint.lookup(blueprintName, {\n      paths: this.project.blueprintLookupPaths()\n    });\n    return blueprint.install(installOptions);\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/tasks/npm-install.js":"'use strict';\n\n// Runs `npm install` in cwd\n\nvar NpmTask = require('./npm-task');\n\nmodule.exports = NpmTask.extend({\n  command: 'install',\n  startProgressMessage: 'Installing packages for tooling via npm',\n  completionMessage: 'Installed packages for tooling via npm.'\n});\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/tasks/npm-task.js":"'use strict';\n\n// Runs `npm install` in cwd\n\nvar chalk = require('chalk');\nvar Task  = require('../models/task');\nvar Promise = require('../ext/promise');\n\nvar spawn = Promise.denodeify(require('child_process').spawn);\n\n\nmodule.exports = Task.extend({\n  // The command to run: can be 'install' or 'uninstall'\n  command: '',\n  // Message to send to ui.startProgress\n  startProgressMessage: '',\n  // Message to send to ui.writeLine on completion\n  completionMessage: '',\n\n  init: function() {\n  },\n  // Options: Boolean verbose\n  run: function(options) {\n    this.ui.startProgress(chalk.green(this.startProgressMessage), chalk.green('.'));\n\n    var npmOptions = {\n      loglevel: options.verbose ? 'verbose' : 'error',\n      logstream: this.ui.outputStream,\n      color: 'always',\n      // by default, do install peoples optional deps\n      'optional': 'optional' in options ? options.optional : true,\n      'save-dev': !!options['save-dev'],\n      'save-exact': !!options['save-exact']\n    };\n\n    var packages = options.packages || [];\n\n    // npm otherwise is otherwise noisy, already submitted PR for npm to fix\n    // misplaced console.log\n    this.disableLogger();\n    return spawn('npm', [this.command].concat(packages, npmOptions)).\n    // return npm(this.command, packages, npmOptions, this.npm).\n      finally(this.finally.bind(this)).\n      then(this.announceCompletion.bind(this));\n  },\n\n  announceCompletion: function() {\n    this.ui.writeLine(chalk.green(this.completionMessage));\n  },\n\n  finally: function() {\n    this.ui.stopProgress();\n    this.restoreLogger();\n  },\n\n  disableLogger: function() {\n    this.oldLog = console.log;\n    console.log = function() {};\n  },\n\n  restoreLogger: function() {\n    console.log = this.oldLog; // Hack, see above\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/cli/cli.js":"'use strict';\n\nvar lookupCommand       = require('./lookup-command');\nvar Promise             = require('../ext/promise');\nvar getOptionArgs       = require('../utilities/get-option-args');\nvar debug               = require('debug')('ember-cli:cli');\nvar debugTesting        = require('debug')('ember-cli:testing');\nvar PlatformChecker     = require('../utilities/platform-checker');\nvar InstallationChecker = require('../models/installation-checker');\n\nfunction CLI(options) {\n  this.name = options.name;\n  this.ui = options.ui;\n  this.testing = options.testing;\n  this.disableDependencyChecker = options.disableDependencyChecker;\n  this.root = options.root;\n  this.npmPackage = options.npmPackage;\n\n  debug('testing %o', !!this.testing);\n}\n\nmodule.exports = CLI;\n\nCLI.prototype.run = function(environment) {\n  return Promise.hash(environment).then(function(environment) {\n    var args = environment.cliArgs.slice();\n\n    if (args[0] === '--help') {\n      if (args.length === 1) {\n        args[0] = 'help';\n      } else {\n        args.shift();\n        args.push('--help');\n      }\n    }\n\n    var commandName = args.shift();\n    var commandArgs = args;\n    var helpOptions;\n    var update;\n\n    var CurrentCommand = lookupCommand(environment.commands, commandName, commandArgs, {\n      project: environment.project,\n      ui: this.ui\n    });\n\n    var command = new CurrentCommand({\n      ui:        this.ui,\n      commands:  environment.commands,\n      tasks:     environment.tasks,\n      project:   environment.project,\n      settings:  environment.settings,\n      testing:   this.testing,\n      cli: this\n    });\n\n    getOptionArgs('--verbose', commandArgs).forEach(function(arg) {\n      process.env['EMBER_VERBOSE_' + arg.toUpperCase()] = 'true';\n    });\n\n    var platform = new PlatformChecker(process.version);\n    if (!platform.isValid && !this.testing) {\n      if (platform.isDeprecated) {\n        this.ui.writeDeprecateLine('Node ' + process.version +\n                                   ' is no longer supported by Angular CLI. Please update to a more recent version of Node');\n      }\n\n      if (platform.isUntested) {\n        this.ui.writeWarnLine('WARNING: Node ' + process.version +\n                              ' has currently not been tested against Angular CLI and may result in unexpected behaviour.');\n      }\n    }\n\n    debug('command: %s', commandName);\n\n    if (!this.testing) {\n      process.chdir(environment.project.root);\n      var skipInstallationCheck = commandArgs.indexOf('--skip-installation-check') !== -1;\n      if (environment.project.isEmberCLIProject() && !skipInstallationCheck) {\n        new InstallationChecker({ project: environment.project }).checkInstallations();\n      }\n    }\n\n    command.beforeRun(commandArgs);\n\n    return Promise.resolve(update).then(function() {\n      debugTesting('cli: command.validateAndRun');\n      return command.validateAndRun(commandArgs);\n    }).then(function(result) {\n      // if the help option was passed, call the help command\n      if (result === 'callHelp') {\n        helpOptions = {\n          environment: environment,\n          commandName: commandName,\n          commandArgs: commandArgs\n        };\n\n        return this.callHelp(helpOptions);\n      }\n\n      return result;\n    }.bind(this)).then(function(exitCode) {\n      debugTesting('cli: command run complete. exitCode: ' + exitCode);\n      // TODO: fix this\n      // Possibly this issue: https://github.com/joyent/node/issues/8329\n      // Wait to resolve promise when running on windows.\n      // This ensures that stdout is flushed so acceptance tests get full output\n\n      return new Promise(function(resolve) {\n        if (process.platform === 'win32') {\n          setTimeout(resolve, 250, exitCode);\n        } else {\n          resolve(exitCode);\n        }\n      });\n    }.bind(this));\n\n  }.bind(this)).catch(this.logError.bind(this));\n};\n\nCLI.prototype.callHelp = function(options) {\n  var environment = options.environment;\n  var commandName = options.commandName;\n  var commandArgs = options.commandArgs;\n  var helpIndex = commandArgs.indexOf('--help');\n  var hIndex = commandArgs.indexOf('-h');\n\n  var HelpCommand = lookupCommand(environment.commands, 'help', commandArgs, {\n    project: environment.project,\n    ui: this.ui\n  });\n\n  var help = new HelpCommand({\n    ui:        this.ui,\n    commands:  environment.commands,\n    tasks:     environment.tasks,\n    project:   environment.project,\n    settings:  environment.settings,\n    testing:   this.testing\n  });\n\n  if (helpIndex > -1) {\n    commandArgs.splice(helpIndex,1);\n  }\n\n  if (hIndex > -1) {\n    commandArgs.splice(hIndex,1);\n  }\n\n  commandArgs.unshift(commandName);\n\n  return help.validateAndRun(commandArgs);\n};\n\nCLI.prototype.logError = function(error) {\n  if (this.testing && error) {\n    console.error(error.message);\n    if (error.stack) {\n      console.error(error.stack);\n    }\n    throw error;\n  }\n  this.ui.errorLog.push(error);\n  this.ui.writeError(error);\n  return 1;\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/cli/lookup-command.js":"'use strict';\n\nvar UnknownCommand = require('../commands/unknown');\n\nmodule.exports = function(commands, commandName, commandArgs, optionHash) {\n  var options = optionHash || {};\n  var project = options.project;\n  var ui      = options.ui;\n\n  function aliasMatches(alias) {\n    return alias === commandName;\n  }\n\n  function findCommand(commands, commandName) {\n    for (var key in commands) {\n      var command = commands[key];\n\n      var name = command.prototype.name;\n      var aliases = command.prototype.aliases || [];\n\n      if (name === commandName || aliases.some(aliasMatches)) {\n        return command;\n      }\n    }\n  }\n\n  // Attempt to find command in ember-cli core commands\n  var command = findCommand(commands, commandName);\n\n  var addonCommand;\n  // Attempt to find command within addons\n  if (project && project.eachAddonCommand) {\n    project.eachAddonCommand(function(addonName, commands) {\n      addonCommand = findCommand(commands, commandName);\n      return !addonCommand;\n    });\n  }\n\n  if (command && addonCommand) {\n    if (addonCommand.overrideCore) {\n      ui.writeWarnLine('An ember-addon has attempted to override the core command \"' +\n              command.prototype.name + '\". The addon command will be used as the overridding was explicit.');\n\n      return addonCommand;\n    }\n\n    ui.writeWarnLine('An ember-addon has attempted to override the core command \"' +\n                            command.prototype.name + '\". The core command will be used.');\n    return command;\n  }\n\n  if (command) {\n    return command;\n  }\n\n  if (addonCommand) {\n    return addonCommand;\n  }\n\n  // if we didn't find anything, return an \"UnknownCommand\"\n  return UnknownCommand.extend({\n    name: commandName\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/utilities/get-option-args.js":"'use strict';\n\nmodule.exports = function(option, commandArgs) {\n  var results = [], value, i;\n  var optionIndex = commandArgs.indexOf(option);\n  if (optionIndex === -1) { return results; }\n\n  for (i = optionIndex + 1; i < commandArgs.length; i++) {\n    value = commandArgs[i];\n    if (/^\\-+/.test(value)) { break; }\n    results.push(value);\n  }\n\n  return results;\n};\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/utilities/platform-checker.js":"'use strict';\n\nvar semver = require('semver');\nvar debug = require('debug')('ember-cli:platform-checker:');\n\nvar LOWER_RANGE = '0.12.0';\nvar UPPER_RANGE = '6.0.0';\n\nmodule.exports = PlatformChecker;\nfunction PlatformChecker(version) {\n  this.version = version;\n  this.isValid = this.checkIsValid();\n  this.isUntested = this.checkIsUntested();\n  this.isDeprecated = this.checkIsDeprecated();\n\n  debug('%o', {\n    version: this.version,\n    isValid: this.isValid,\n    isUntested: this.isUntested,\n    isDeprecated: this.isDeprecated\n  });\n}\n\nPlatformChecker.prototype.checkIsValid = function() {\n  return semver.satisfies(this.version, '>=' + LOWER_RANGE + ' <' + UPPER_RANGE);\n};\n\nPlatformChecker.prototype.checkIsDeprecated = function() {\n  return semver.satisfies(this.version, '<' + LOWER_RANGE);\n};\n\nPlatformChecker.prototype.checkIsUntested = function() {\n  return semver.satisfies(this.version, '>=' + UPPER_RANGE);\n};\n\n","/home/travis/build/npmtest/node-npmtest-angular-cli/angular-cli/ember-cli/lib/models/installation-checker.js":"'use strict';\n\nvar debug       = require('debug')('ember-cli:installation-checker');\nvar fs          = require('fs');\nvar existsSync  = require('exists-sync');\nvar path        = require('path');\nvar SilentError = require('silent-error');\n\nmodule.exports = InstallationChecker;\n\nfunction InstallationChecker(options) {\n  this.project = options.project;\n}\n\n/**\n* Check if npm directories are present,\n* and raise an error message with instructions on how to proceed.\n*\n* If some of these package managers aren't being used in the project\n* we just ignore them. Their usage is considered by checking the\n* presence of your manifest files: package.json for npm.\n*/\nInstallationChecker.prototype.checkInstallations = function() {\n  var commands = [];\n\n  if (this.usingNpm() && this.npmDependenciesNotPresent()) {\n    debug('npm dependencies not installed');\n    commands.push('`npm install`');\n  }\n  if (commands.length) {\n    var commandText = commands.join(' and ');\n    throw new SilentError('No dependencies installed. Run ' + commandText + ' to install missing dependencies.');\n  }\n};\n\nfunction hasDependencies(pkg) {\n  return (pkg.dependencies && pkg.dependencies.length) ||\n         (pkg.devDependencies && pkg.devDependencies.length);\n}\n\nfunction readJSON(path) {\n  try {\n    return JSON.parse(fs.readFileSync(path).toString());\n  } catch (e) {\n    throw new SilentError('InstallationChecker: Unable to parse: ' + path);\n  }\n}\n\nInstallationChecker.prototype.hasNpmDeps = function() {\n  return hasDependencies(readJSON(path.join(this.project.root, 'package.json')));\n};\n\nInstallationChecker.prototype.usingNpm = function() {\n  return existsSync(path.join(this.project.root, 'package.json')) && this.hasNpmDeps();\n};\n\nInstallationChecker.prototype.npmDependenciesNotPresent = function() {\n  return !existsSync(this.project.nodeModulesPath);\n};\n"}